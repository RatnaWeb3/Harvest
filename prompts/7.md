# Prompt 7: Add Echelon and LayerBank Lending Integrations

## Objective
Integrate Echelon money market and LayerBank lending protocols for tracking supply/borrow positions and interest rewards.

## Pre-Flight Checklist
- [ ] Read `docs/issues/move/README.md` for any Move issues
- [ ] Read `docs/protocol-research.md` for protocol addresses
- [ ] Ensure Prompts 1-6 completed
- [ ] Load skill: `move-dev`

## Context
Both Echelon and LayerBank are lending protocols. Users can:
- Supply assets to earn interest
- Borrow assets against collateral
- Claim interest/incentive rewards

## Tasks

### 1. Create Echelon Configuration
**frontend/constants/protocols/echelon.ts**:

```typescript
const ECHELON_MODULE_ADDRESS =
  process.env.NEXT_PUBLIC_ECHELON_ADDRESS || '0x...'

export const ECHELON_CONFIG = {
  moduleAddress: ECHELON_MODULE_ADDRESS,
  displayName: 'Echelon',
  color: '#10B981', // Emerald
  icon: 'echelon',

  viewFunctions: {
    getUserSupplies: `${ECHELON_MODULE_ADDRESS}::lending::get_user_supplies`,
    getUserBorrows: `${ECHELON_MODULE_ADDRESS}::lending::get_user_borrows`,
    getPendingRewards: `${ECHELON_MODULE_ADDRESS}::rewards::pending`,
    getHealthFactor: `${ECHELON_MODULE_ADDRESS}::lending::health_factor`,
  },

  entryFunctions: {
    supply: `${ECHELON_MODULE_ADDRESS}::lending::supply`,
    withdraw: `${ECHELON_MODULE_ADDRESS}::lending::withdraw`,
    borrow: `${ECHELON_MODULE_ADDRESS}::lending::borrow`,
    repay: `${ECHELON_MODULE_ADDRESS}::lending::repay`,
    claimRewards: `${ECHELON_MODULE_ADDRESS}::rewards::claim`,
  },

  // Supported assets
  markets: [
    { symbol: 'MOVE', address: '0x...', decimals: 8 },
    { symbol: 'USDC', address: '0x...', decimals: 6 },
    { symbol: 'USDT', address: '0x...', decimals: 6 },
    { symbol: 'ETH', address: '0x...', decimals: 8 },
  ],
} as const

export const isEchelonDeployed = (): boolean => {
  return ECHELON_MODULE_ADDRESS !== '0x...'
}
```

### 2. Create LayerBank Configuration
**frontend/constants/protocols/layerbank.ts**:

```typescript
const LAYERBANK_MODULE_ADDRESS =
  process.env.NEXT_PUBLIC_LAYERBANK_ADDRESS || '0x...'

export const LAYERBANK_CONFIG = {
  moduleAddress: LAYERBANK_MODULE_ADDRESS,
  displayName: 'LayerBank',
  color: '#8B5CF6', // Violet
  icon: 'layerbank',

  viewFunctions: {
    getAccountSnapshot: `${LAYERBANK_MODULE_ADDRESS}::core::account_snapshot`,
    getPendingRewards: `${LAYERBANK_MODULE_ADDRESS}::incentives::pending`,
  },

  entryFunctions: {
    mint: `${LAYERBANK_MODULE_ADDRESS}::core::mint`,
    redeem: `${LAYERBANK_MODULE_ADDRESS}::core::redeem`,
    borrow: `${LAYERBANK_MODULE_ADDRESS}::core::borrow`,
    repay: `${LAYERBANK_MODULE_ADDRESS}::core::repay`,
    claimRewards: `${LAYERBANK_MODULE_ADDRESS}::incentives::claim`,
  },

  markets: [
    { symbol: 'MOVE', lToken: 'lMOVE', decimals: 8 },
    { symbol: 'USDC', lToken: 'lUSDC', decimals: 6 },
  ],
} as const
```

### 3. Create Echelon Service
**frontend/lib/services/echelon-service.ts**:

```typescript
import { aptos, TransactionPayload } from '@/lib/move'
import { ProtocolService, Position, RewardItem, ProtocolId } from './protocol-interface'
import { ECHELON_CONFIG, isEchelonDeployed } from '@/constants/protocols/echelon'

class EchelonService implements ProtocolService {
  readonly protocolId: ProtocolId = 'echelon'
  readonly displayName = 'Echelon'

  async getPositions(address: string): Promise<Position[]> {
    if (!isEchelonDeployed()) return []

    try {
      const [supplies, borrows, healthFactor] = await Promise.all([
        this.getUserSupplies(address),
        this.getUserBorrows(address),
        this.getHealthFactor(address),
      ])

      const supplyPositions = supplies.map((s) => ({
        id: `echelon-supply-${s.asset}`,
        protocolId: 'echelon' as ProtocolId,
        type: 'lending' as const,
        tokenSymbol: s.asset,
        tokenAddress: s.address,
        amount: s.amount,
        valueUsd: s.valueUsd,
        apy: s.supplyApy,
        metadata: {
          positionType: 'supply',
          healthFactor,
        },
      }))

      const borrowPositions = borrows.map((b) => ({
        id: `echelon-borrow-${b.asset}`,
        protocolId: 'echelon' as ProtocolId,
        type: 'lending' as const,
        tokenSymbol: b.asset,
        tokenAddress: b.address,
        amount: `-${b.amount}`, // Negative for borrows
        valueUsd: -b.valueUsd,
        apy: -b.borrowApy, // Negative APY (cost)
        metadata: {
          positionType: 'borrow',
          healthFactor,
        },
      }))

      return [...supplyPositions, ...borrowPositions]
    } catch (error) {
      console.error('[Echelon] Error fetching positions:', error)
      return []
    }
  }

  async getPendingRewards(address: string): Promise<RewardItem[]> {
    if (!isEchelonDeployed()) return []

    try {
      const result = await aptos.view({
        payload: {
          function: ECHELON_CONFIG.viewFunctions.getPendingRewards,
          typeArguments: [],
          functionArguments: [address],
        },
      })

      // Parse rewards array
      return this.parseRewards(result, address)
    } catch (error) {
      console.error('[Echelon] Error fetching rewards:', error)
      return []
    }
  }

  async buildClaimTransaction(address: string): Promise<TransactionPayload> {
    return {
      function: ECHELON_CONFIG.entryFunctions.claimRewards,
      typeArguments: [],
      functionArguments: [],
    }
  }

  private async getUserSupplies(address: string) {
    const result = await aptos.view({
      payload: {
        function: ECHELON_CONFIG.viewFunctions.getUserSupplies,
        typeArguments: [],
        functionArguments: [address],
      },
    })
    return this.parseSupplies(result)
  }

  private async getUserBorrows(address: string) {
    const result = await aptos.view({
      payload: {
        function: ECHELON_CONFIG.viewFunctions.getUserBorrows,
        typeArguments: [],
        functionArguments: [address],
      },
    })
    return this.parseBorrows(result)
  }

  private async getHealthFactor(address: string): Promise<number> {
    const result = await aptos.view({
      payload: {
        function: ECHELON_CONFIG.viewFunctions.getHealthFactor,
        typeArguments: [],
        functionArguments: [address],
      },
    })
    return Number(result[0]) / 100 // Assuming percentage
  }
}

export const echelonService = new EchelonService()
```

### 4. Create LayerBank Service
**frontend/lib/services/layerbank-service.ts**:

```typescript
// Similar structure to Echelon
// Implement getPositions, getPendingRewards, buildClaimTransaction
// Handle lTokens (wrapped tokens)
```

### 5. Create Lending Position Card
**frontend/components/protocols/lending/lending-position-card.tsx**:

```typescript
import { Card } from '@/components/ui/card'
import { Position } from '@/lib/services/protocol-interface'
import { HealthBadge } from './health-badge'

interface LendingPositionCardProps {
  position: Position
}

export function LendingPositionCard({ position }: LendingPositionCardProps) {
  const isSupply = position.metadata?.positionType === 'supply'
  const healthFactor = position.metadata?.healthFactor

  return (
    <Card className="p-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <ProtocolBadge protocolId={position.protocolId} />
          <div>
            <p className="font-medium">
              {isSupply ? 'Supplied' : 'Borrowed'} {position.tokenSymbol}
            </p>
            <p className="text-sm text-muted-foreground">
              {Math.abs(position.apy).toFixed(2)}% {isSupply ? 'APY' : 'APR'}
            </p>
          </div>
        </div>

        <div className="text-right">
          <TokenDisplay
            amount={position.amount}
            symbol={position.tokenSymbol}
            usdValue={Math.abs(position.valueUsd)}
          />
        </div>
      </div>

      {healthFactor && (
        <div className="mt-3">
          <HealthBadge factor={healthFactor} />
        </div>
      )}
    </Card>
  )
}
```

### 6. Create Health Factor Badge
**frontend/components/protocols/lending/health-badge.tsx**:

```typescript
import { Badge } from '@/components/ui/badge'

interface HealthBadgeProps {
  factor: number
}

export function HealthBadge({ factor }: HealthBadgeProps) {
  const getColor = () => {
    if (factor >= 2) return 'bg-green-500'
    if (factor >= 1.5) return 'bg-yellow-500'
    if (factor >= 1.1) return 'bg-orange-500'
    return 'bg-red-500'
  }

  return (
    <Badge className={getColor()}>
      Health: {factor.toFixed(2)}
    </Badge>
  )
}
```

### 7. Register Services
Update `protocol-registry.ts` and `protocols/index.ts` to include both new protocols.

### 8. Add Move Adapters
Create `echelon_adapter.move` and `layerbank_adapter.move` in contracts.

## Deliverables
- [ ] Created Echelon config, service, and components
- [ ] Created LayerBank config, service, and components
- [ ] Created shared lending position card
- [ ] Created health factor badge component
- [ ] Registered both services
- [ ] Created Move adapters

## Verification
```bash
cd frontend && yarn build
yarn dev
# Connect wallet with Echelon/LayerBank positions
# Verify positions appear with correct health factors
```

## Testing
- [ ] Supply positions show positive APY
- [ ] Borrow positions show negative APY (cost)
- [ ] Health factor displays correctly
- [ ] Claim rewards works
- [ ] Portfolio totals calculate correctly

## Notes
- Handle case where user has no borrows (infinite health factor)
- Keep services under 250 lines each
- Reuse lending-position-card for both protocols
- Health factor < 1 means liquidatable - show warning
