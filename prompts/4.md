# Prompt 4: Implement Real Protocol Data Fetching

## Objective
Replace all mock data in protocol services with real on-chain data fetching using the indexer (from Prompt 3) and direct RPC calls.

## Pre-Flight Checklist
- [ ] Read `docs/issues/move/README.md` for Move SDK issues
- [ ] Read `docs/issues/indexer/README.md` for indexer issues
- [ ] Ensure Prompt 3 completed (GraphQL client set up)
- [ ] Load skill: `move-dev` (for Aptos SDK usage)

## Context
Protocol services in `frontend/lib/services/` currently return mock data. We need to:
1. Fetch real positions from indexer
2. Calculate real pending rewards from on-chain
3. Build real transaction payloads

## Tasks

### 1. Update Yuzu Service
**lib/services/yuzu-service.ts**:

```typescript
async getPositions(address: string): Promise<Position[]> {
  // 1. Query position NFTs from indexer
  const nfts = await fetchYuzuPositionNFTs(address)

  // 2. For each position, get on-chain data
  const positions = await Promise.all(
    nfts.map(async (nft) => {
      const positionData = await this.getPositionOnChain(nft.tokenId)
      return this.parsePosition(nft, positionData)
    })
  )

  return positions
}

async getPendingRewards(address: string): Promise<RewardItem[]> {
  const positions = await this.getPositions(address)

  // For each position, calculate accrued fees
  const rewards = await Promise.all(
    positions.map(async (pos) => {
      // Call view function to get tokens_owed_0, tokens_owed_1
      const fees = await this.getAccruedFees(pos.metadata.positionId)
      return this.parseRewards(pos, fees)
    })
  )

  return rewards.flat()
}

private async getAccruedFees(positionId: number) {
  const result = await aptos.view({
    payload: {
      function: `${YUZU_CONFIG.moduleAddress}::position_manager::get_position`,
      typeArguments: [],
      functionArguments: [positionId.toString()],
    },
  })
  return {
    tokensOwed0: BigInt(result[0] as string),
    tokensOwed1: BigInt(result[1] as string),
  }
}
```

### 2. Update Joule Service
**lib/services/joule-service.ts**:

```typescript
async getPositions(address: string): Promise<Position[]> {
  // Query user's supply/borrow positions
  const supplies = await this.getUserSupplies(address)
  const borrows = await this.getUserBorrows(address)

  return [...supplies, ...borrows]
}

private async getUserSupplies(address: string) {
  // Call Joule view function
  const result = await aptos.view({
    payload: {
      function: `${JOULE_CONFIG.moduleAddress}::lending::get_user_supplies`,
      typeArguments: [],
      functionArguments: [address],
    },
  })
  return this.parseSupplyPositions(result)
}

async getPendingRewards(address: string): Promise<RewardItem[]> {
  // Get pending interest rewards
  const result = await aptos.view({
    payload: {
      function: `${JOULE_CONFIG.moduleAddress}::rewards::get_pending`,
      typeArguments: [],
      functionArguments: [address],
    },
  })
  return this.parseRewards(result)
}
```

### 3. Update Meridian Service
**lib/services/meridian-service.ts**:

```typescript
async getPositions(address: string): Promise<Position[]> {
  // Query staking positions
  const result = await aptos.view({
    payload: {
      function: `${MERIDIAN_CONFIG.moduleAddress}::staking::get_user_stakes`,
      typeArguments: [],
      functionArguments: [address],
    },
  })
  return this.parsePositions(result)
}

async getPendingRewards(address: string): Promise<RewardItem[]> {
  const result = await aptos.view({
    payload: {
      function: `${MERIDIAN_CONFIG.moduleAddress}::rewards::pending_rewards`,
      typeArguments: [],
      functionArguments: [address],
    },
  })
  return this.parseRewards(result)
}
```

### 4. Create Parser Utilities
Update parsers in `lib/services/parsers/`:

**yuzu-parser.ts**:
```typescript
export function parseYuzuPosition(
  nft: IndexerPositionNFT,
  onChainData: OnChainPositionData
): Position {
  return {
    id: `yuzu-${nft.tokenId}`,
    protocolId: 'yuzu',
    type: 'lp',
    tokenSymbol: `${nft.token0Symbol}/${nft.token1Symbol}`,
    tokenAddress: nft.poolAddress,
    amount: formatLiquidity(onChainData.liquidity),
    valueUsd: calculatePositionValue(onChainData, prices),
    apy: calculatePoolAPY(nft.poolAddress),
    metadata: {
      positionId: nft.tokenId,
      tickLower: onChainData.tickLower,
      tickUpper: onChainData.tickUpper,
      liquidity: onChainData.liquidity.toString(),
    },
  }
}
```

### 5. Add Price Service
Create `lib/services/price-service.ts`:
```typescript
export async function getTokenPrices(tokens: string[]): Promise<Record<string, number>> {
  // Fetch from CoinGecko, DefiLlama, or protocol APIs
  const prices: Record<string, number> = {}

  // Implement price fetching
  for (const token of tokens) {
    prices[token] = await fetchTokenPrice(token)
  }

  return prices
}
```

### 6. Update Error Handling
Ensure graceful degradation:
```typescript
async getPositions(address: string): Promise<Position[]> {
  try {
    return await this.fetchRealPositions(address)
  } catch (error) {
    console.error('[Yuzu] Failed to fetch positions:', error)

    // In production, return empty - don't show fake data
    if (process.env.NODE_ENV === 'production') {
      return []
    }

    // In development, use mock for testing UI
    console.warn('[Yuzu] Using mock data for development')
    return MOCK_POSITIONS
  }
}
```

## Deliverables
- [ ] Updated `yuzu-service.ts` with real data fetching
- [ ] Updated `joule-service.ts` with real data fetching
- [ ] Updated `meridian-service.ts` with real data fetching
- [ ] Created/updated parser files
- [ ] Created `price-service.ts`
- [ ] All services handle errors gracefully

## Verification
```bash
# Start dev server
cd frontend && yarn dev

# Connect wallet with real Movement positions
# Verify real data appears (not mock)
# Check console for successful RPC calls
```

## Testing Checklist
- [ ] Wallet with Yuzu LP positions shows real data
- [ ] Wallet with Joule lending positions shows real data
- [ ] Wallet with Meridian stakes shows real data
- [ ] Empty wallet shows "No positions" (not mock data)
- [ ] Pending rewards calculate correctly
- [ ] USD values display correctly

## Notes
- Use Context7 MCP for Aptos SDK documentation
- Keep services under 300 lines - split if needed
- Log all RPC calls for debugging
- Cache responses with React Query (already set up)
