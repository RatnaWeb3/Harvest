# Prompt 10: Build Backend API Infrastructure

## Objective
Build the Node.js backend API for user settings, caching, leaderboard aggregation, and scheduled jobs.

## Pre-Flight Checklist
- [ ] Read `docs/issues/tooling/README.md` for any tooling issues
- [ ] Ensure frontend prompts (1-9) are complete
- [ ] Have PostgreSQL and Redis available (local or cloud)

## Context
The PRD specifies a backend for:
- User settings storage
- Position/price caching
- Leaderboard aggregation
- Auto-compound scheduler
- Notification dispatch

## Tasks

### 1. Initialize Backend Project
```bash
mkdir -p backend
cd backend
npm init -y
npm install express cors helmet rate-limiter-flexible
npm install pg redis bullmq
npm install @aptos-labs/ts-sdk
npm install -D typescript @types/node @types/express ts-node nodemon
npx tsc --init
```

### 2. Create Project Structure
```
backend/
├── src/
│   ├── index.ts              # Express app entry
│   ├── config/
│   │   ├── database.ts       # PostgreSQL config
│   │   ├── redis.ts          # Redis config
│   │   └── env.ts            # Environment variables
│   ├── routes/
│   │   ├── index.ts          # Route aggregator
│   │   ├── users.ts          # User settings routes
│   │   ├── portfolio.ts      # Portfolio data routes
│   │   ├── leaderboard.ts    # Leaderboard routes
│   │   └── airdrops.ts       # Airdrop routes
│   ├── services/
│   │   ├── portfolio-service.ts
│   │   ├── leaderboard-service.ts
│   │   ├── price-service.ts
│   │   └── notification-service.ts
│   ├── jobs/
│   │   ├── queue.ts          # BullMQ queue setup
│   │   ├── price-updater.ts  # Update token prices
│   │   └── leaderboard-calc.ts # Calculate rankings
│   ├── middleware/
│   │   ├── auth.ts           # Wallet signature verification
│   │   └── rate-limit.ts     # Rate limiting
│   └── types/
│       └── index.ts          # Shared types
├── migrations/               # Database migrations
├── package.json
└── tsconfig.json
```

### 3. Create Express App
**src/index.ts**:

```typescript
import express from 'express'
import cors from 'cors'
import helmet from 'helmet'
import { router } from './routes'
import { initDatabase } from './config/database'
import { initRedis } from './config/redis'
import { initQueues } from './jobs/queue'

const app = express()
const PORT = process.env.PORT || 4000

app.use(helmet())
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
}))
app.use(express.json())

// Routes
app.use('/api', router)

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: Date.now() })
})

async function start() {
  await initDatabase()
  await initRedis()
  await initQueues()

  app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`)
  })
}

start().catch(console.error)
```

### 4. Create Database Schema
**migrations/001_initial.sql**:

```sql
-- User settings
CREATE TABLE users (
  address VARCHAR(66) PRIMARY KEY,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  settings JSONB DEFAULT '{}',
  notification_preferences JSONB DEFAULT '{}'
);

-- Claim history
CREATE TABLE claims (
  id SERIAL PRIMARY KEY,
  user_address VARCHAR(66) NOT NULL,
  protocol VARCHAR(50) NOT NULL,
  token_symbol VARCHAR(20) NOT NULL,
  amount DECIMAL(36, 18) NOT NULL,
  value_usd DECIMAL(18, 2) NOT NULL,
  tx_hash VARCHAR(66) NOT NULL,
  claimed_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (user_address) REFERENCES users(address)
);

-- Leaderboard snapshots
CREATE TABLE leaderboard_snapshots (
  id SERIAL PRIMARY KEY,
  period VARCHAR(20) NOT NULL, -- 'daily', 'weekly', 'monthly', 'alltime'
  user_address VARCHAR(66) NOT NULL,
  rank INTEGER NOT NULL,
  total_claimed DECIMAL(18, 2) NOT NULL,
  claim_count INTEGER NOT NULL,
  streak_days INTEGER DEFAULT 0,
  snapshot_at TIMESTAMP DEFAULT NOW()
);

-- Price cache
CREATE TABLE token_prices (
  address VARCHAR(66) PRIMARY KEY,
  symbol VARCHAR(20) NOT NULL,
  price_usd DECIMAL(18, 8) NOT NULL,
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_claims_user ON claims(user_address);
CREATE INDEX idx_claims_date ON claims(claimed_at);
CREATE INDEX idx_leaderboard_period ON leaderboard_snapshots(period, snapshot_at);
```

### 5. Create User Routes
**src/routes/users.ts**:

```typescript
import { Router } from 'express'
import { pool } from '../config/database'
import { verifySignature } from '../middleware/auth'

const router = Router()

// Get user settings
router.get('/:address', async (req, res) => {
  const { address } = req.params

  const result = await pool.query(
    'SELECT * FROM users WHERE address = $1',
    [address.toLowerCase()]
  )

  if (result.rows.length === 0) {
    return res.json({ address, settings: {}, notification_preferences: {} })
  }

  res.json(result.rows[0])
})

// Update user settings (requires signature)
router.put('/:address', verifySignature, async (req, res) => {
  const { address } = req.params
  const { settings, notification_preferences } = req.body

  await pool.query(`
    INSERT INTO users (address, settings, notification_preferences)
    VALUES ($1, $2, $3)
    ON CONFLICT (address) DO UPDATE SET
      settings = COALESCE($2, users.settings),
      notification_preferences = COALESCE($3, users.notification_preferences),
      updated_at = NOW()
  `, [address.toLowerCase(), settings, notification_preferences])

  res.json({ success: true })
})

// Get claim history
router.get('/:address/claims', async (req, res) => {
  const { address } = req.params
  const { limit = 50, offset = 0 } = req.query

  const result = await pool.query(`
    SELECT * FROM claims
    WHERE user_address = $1
    ORDER BY claimed_at DESC
    LIMIT $2 OFFSET $3
  `, [address.toLowerCase(), limit, offset])

  res.json(result.rows)
})

// Record a claim
router.post('/:address/claims', verifySignature, async (req, res) => {
  const { address } = req.params
  const { protocol, token_symbol, amount, value_usd, tx_hash } = req.body

  await pool.query(`
    INSERT INTO claims (user_address, protocol, token_symbol, amount, value_usd, tx_hash)
    VALUES ($1, $2, $3, $4, $5, $6)
  `, [address.toLowerCase(), protocol, token_symbol, amount, value_usd, tx_hash])

  res.json({ success: true })
})

export { router as usersRouter }
```

### 6. Create Leaderboard Routes
**src/routes/leaderboard.ts**:

```typescript
import { Router } from 'express'
import { redis } from '../config/redis'
import { pool } from '../config/database'

const router = Router()

// Get leaderboard
router.get('/', async (req, res) => {
  const { period = 'weekly', limit = 100 } = req.query

  // Try cache first
  const cacheKey = `leaderboard:${period}:${limit}`
  const cached = await redis.get(cacheKey)
  if (cached) {
    return res.json(JSON.parse(cached))
  }

  // Calculate from claims
  const result = await pool.query(`
    SELECT
      user_address,
      SUM(value_usd) as total_claimed,
      COUNT(*) as claim_count
    FROM claims
    WHERE claimed_at > NOW() - INTERVAL '1 ${period === 'daily' ? 'day' : period === 'weekly' ? 'week' : 'month'}'
    GROUP BY user_address
    ORDER BY total_claimed DESC
    LIMIT $1
  `, [limit])

  const leaderboard = result.rows.map((row, index) => ({
    rank: index + 1,
    address: row.user_address,
    totalClaimed: parseFloat(row.total_claimed),
    claimCount: parseInt(row.claim_count),
  }))

  // Cache for 5 minutes
  await redis.setex(cacheKey, 300, JSON.stringify(leaderboard))

  res.json(leaderboard)
})

// Get user rank
router.get('/rank/:address', async (req, res) => {
  const { address } = req.params
  const { period = 'weekly' } = req.query

  const result = await pool.query(`
    WITH ranked AS (
      SELECT
        user_address,
        SUM(value_usd) as total_claimed,
        RANK() OVER (ORDER BY SUM(value_usd) DESC) as rank
      FROM claims
      WHERE claimed_at > NOW() - INTERVAL '1 ${period === 'daily' ? 'day' : period === 'weekly' ? 'week' : 'month'}'
      GROUP BY user_address
    )
    SELECT * FROM ranked WHERE user_address = $1
  `, [address.toLowerCase()])

  if (result.rows.length === 0) {
    return res.json({ rank: null, totalClaimed: 0 })
  }

  res.json({
    rank: parseInt(result.rows[0].rank),
    totalClaimed: parseFloat(result.rows[0].total_claimed),
  })
})

export { router as leaderboardRouter }
```

### 7. Create Price Service
**src/services/price-service.ts**:

```typescript
import { redis } from '../config/redis'
import { pool } from '../config/database'

const COINGECKO_API = 'https://api.coingecko.com/api/v3'

class PriceService {
  async getTokenPrice(symbol: string): Promise<number> {
    // Check Redis cache
    const cached = await redis.get(`price:${symbol}`)
    if (cached) return parseFloat(cached)

    // Check database
    const result = await pool.query(
      'SELECT price_usd FROM token_prices WHERE symbol = $1',
      [symbol]
    )
    if (result.rows.length > 0) {
      const price = parseFloat(result.rows[0].price_usd)
      await redis.setex(`price:${symbol}`, 60, price.toString())
      return price
    }

    // Fetch from API
    return this.fetchAndCachePrice(symbol)
  }

  async getAllPrices(): Promise<Record<string, number>> {
    const result = await pool.query('SELECT symbol, price_usd FROM token_prices')
    return Object.fromEntries(
      result.rows.map(r => [r.symbol, parseFloat(r.price_usd)])
    )
  }

  async fetchAndCachePrice(symbol: string): Promise<number> {
    try {
      const response = await fetch(
        `${COINGECKO_API}/simple/price?ids=${symbol}&vs_currencies=usd`
      )
      const data = await response.json()
      const price = data[symbol]?.usd || 0

      // Update database
      await pool.query(`
        INSERT INTO token_prices (address, symbol, price_usd, updated_at)
        VALUES ($1, $2, $3, NOW())
        ON CONFLICT (symbol) DO UPDATE SET
          price_usd = $3, updated_at = NOW()
      `, [symbol, symbol, price])

      // Update Redis
      await redis.setex(`price:${symbol}`, 60, price.toString())

      return price
    } catch (error) {
      console.error(`Failed to fetch price for ${symbol}:`, error)
      return 0
    }
  }
}

export const priceService = new PriceService()
```

### 8. Create Background Jobs
**src/jobs/queue.ts**:

```typescript
import { Queue, Worker } from 'bullmq'
import { redis } from '../config/redis'

export const priceQueue = new Queue('prices', { connection: redis })
export const leaderboardQueue = new Queue('leaderboard', { connection: redis })

export async function initQueues() {
  // Price updater - every 1 minute
  await priceQueue.add('update-prices', {}, {
    repeat: { every: 60000 }
  })

  // Leaderboard calculator - every 5 minutes
  await leaderboardQueue.add('calculate-rankings', {}, {
    repeat: { every: 300000 }
  })
}
```

**src/jobs/price-updater.ts**:

```typescript
import { Worker } from 'bullmq'
import { redis } from '../config/redis'
import { priceService } from '../services/price-service'

const TOKENS = ['movement', 'usd-coin', 'tether', 'ethereum']

export const priceWorker = new Worker('prices', async (job) => {
  console.log('Updating token prices...')

  for (const token of TOKENS) {
    await priceService.fetchAndCachePrice(token)
  }

  console.log('Prices updated')
}, { connection: redis })
```

### 9. Create Environment Config
**src/config/env.ts**:

```typescript
export const config = {
  port: process.env.PORT || 4000,
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:3000',

  database: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432'),
    database: process.env.DB_NAME || 'harvest',
    user: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || '',
  },

  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
  },

  movement: {
    rpcUrl: process.env.MOVEMENT_RPC_URL || 'https://mainnet.movementnetwork.xyz/v1',
  },
}
```

### 10. Add Scripts to package.json
```json
{
  "scripts": {
    "dev": "nodemon --exec ts-node src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "migrate": "psql $DATABASE_URL < migrations/001_initial.sql"
  }
}
```

## Deliverables
- [ ] Created `backend/` directory structure
- [ ] Set up Express with middleware
- [ ] Created database schema and migrations
- [ ] Implemented user settings routes
- [ ] Implemented leaderboard routes
- [ ] Created price service with caching
- [ ] Set up BullMQ background jobs
- [ ] Created environment configuration

## Verification
```bash
cd backend
npm install
# Set up PostgreSQL and Redis locally or use Docker
docker-compose up -d postgres redis
npm run migrate
npm run dev

# Test endpoints
curl http://localhost:4000/health
curl http://localhost:4000/api/leaderboard
```

## Docker Compose (for local development)
```yaml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: harvest
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
  redis:
    image: redis:7
    ports:
      - "6379:6379"
```

## Notes
- Keep route files under 200 lines
- Keep services under 250 lines
- Use connection pooling for PostgreSQL
- Implement proper error handling
- Add request validation with zod or similar
