# Prompt 11: Connect Frontend to Backend API

## Objective
Connect the frontend to the new backend API for real data persistence and remove mock data dependencies.

## Pre-Flight Checklist
- [ ] Read `docs/issues/ui/README.md` for any UI issues
- [ ] Ensure Prompt 10 completed (backend running)
- [ ] Backend API accessible at configured URL
- [ ] Load skill: `ui-dev`

## Context
The frontend currently:
- Uses mock data for leaderboard
- Has no persistence for claim history
- Doesn't save user settings
- Has mock airdrop data

We need to connect to the backend for real data.

## Tasks

### 1. Create API Client
**frontend/lib/api/client.ts**:

```typescript
const API_BASE = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:4000/api'

class ApiClient {
  private baseUrl: string

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }

  async get<T>(path: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}${path}`, {
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`API error: ${response.status}`)
    }

    return response.json()
  }

  async post<T>(path: string, data: unknown, signature?: string): Promise<T> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    }

    if (signature) {
      headers['X-Signature'] = signature
    }

    const response = await fetch(`${this.baseUrl}${path}`, {
      method: 'POST',
      headers,
      body: JSON.stringify(data),
    })

    if (!response.ok) {
      throw new Error(`API error: ${response.status}`)
    }

    return response.json()
  }

  async put<T>(path: string, data: unknown, signature?: string): Promise<T> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    }

    if (signature) {
      headers['X-Signature'] = signature
    }

    const response = await fetch(`${this.baseUrl}${path}`, {
      method: 'PUT',
      headers,
      body: JSON.stringify(data),
    })

    if (!response.ok) {
      throw new Error(`API error: ${response.status}`)
    }

    return response.json()
  }
}

export const apiClient = new ApiClient(API_BASE)
```

### 2. Create API Service Layer
**frontend/lib/api/index.ts**:

```typescript
import { apiClient } from './client'
import { LeaderboardEntry, ClaimRecord, UserSettings } from './types'

export const api = {
  // Leaderboard
  getLeaderboard: (period: string = 'weekly', limit: number = 100) =>
    apiClient.get<LeaderboardEntry[]>(`/leaderboard?period=${period}&limit=${limit}`),

  getUserRank: (address: string, period: string = 'weekly') =>
    apiClient.get<{ rank: number | null; totalClaimed: number }>(
      `/leaderboard/rank/${address}?period=${period}`
    ),

  // User
  getUserSettings: (address: string) =>
    apiClient.get<UserSettings>(`/users/${address}`),

  updateUserSettings: (address: string, settings: Partial<UserSettings>, signature: string) =>
    apiClient.put(`/users/${address}`, settings, signature),

  // Claims
  getClaimHistory: (address: string, limit: number = 50, offset: number = 0) =>
    apiClient.get<ClaimRecord[]>(`/users/${address}/claims?limit=${limit}&offset=${offset}`),

  recordClaim: (
    address: string,
    claim: Omit<ClaimRecord, 'id' | 'claimed_at'>,
    signature: string
  ) => apiClient.post(`/users/${address}/claims`, claim, signature),

  // Prices
  getTokenPrices: () =>
    apiClient.get<Record<string, number>>('/prices'),
}
```

### 3. Create API Types
**frontend/lib/api/types.ts**:

```typescript
export interface LeaderboardEntry {
  rank: number
  address: string
  totalClaimed: number
  claimCount: number
  streakDays?: number
}

export interface ClaimRecord {
  id: number
  protocol: string
  token_symbol: string
  amount: string
  value_usd: number
  tx_hash: string
  claimed_at: string
}

export interface UserSettings {
  address: string
  settings: {
    theme?: 'light' | 'dark'
    defaultCompoundStrategy?: string
    hideSmallRewards?: boolean
    smallRewardThreshold?: number
  }
  notification_preferences: {
    email?: string
    telegram?: string
    discord?: string
    notifyOnNewRewards?: boolean
    notifyOnAirdrops?: boolean
    notifyOnPriceAlerts?: boolean
  }
}
```

### 4. Update Leaderboard Hook
**frontend/app/leaderboard/hooks/use-leaderboard.ts**:

```typescript
import { useQuery } from '@tanstack/react-query'
import { api } from '@/lib/api'
import { useAptosWallet } from '@/lib/move'

export function useLeaderboard(period: string = 'weekly') {
  const { account } = useAptosWallet()

  const leaderboardQuery = useQuery({
    queryKey: ['leaderboard', period],
    queryFn: () => api.getLeaderboard(period, 100),
    staleTime: 5 * 60 * 1000, // 5 minutes
  })

  const userRankQuery = useQuery({
    queryKey: ['user-rank', account?.address, period],
    queryFn: () => api.getUserRank(account!.address, period),
    enabled: !!account?.address,
    staleTime: 5 * 60 * 1000,
  })

  return {
    leaderboard: leaderboardQuery.data,
    userRank: userRankQuery.data,
    isLoading: leaderboardQuery.isLoading || userRankQuery.isLoading,
    isError: leaderboardQuery.isError || userRankQuery.isError,
  }
}
```

### 5. Update Claim History Hook
**frontend/app/rewards/hooks/use-claim-history.ts**:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { api } from '@/lib/api'
import { useAptosWallet } from '@/lib/move'

export function useClaimHistory() {
  const { account, signMessage } = useAptosWallet()
  const queryClient = useQueryClient()

  const historyQuery = useQuery({
    queryKey: ['claim-history', account?.address],
    queryFn: () => api.getClaimHistory(account!.address),
    enabled: !!account?.address,
  })

  const recordClaimMutation = useMutation({
    mutationFn: async (claim: {
      protocol: string
      token_symbol: string
      amount: string
      value_usd: number
      tx_hash: string
    }) => {
      if (!account) throw new Error('No wallet connected')

      // Sign message to verify ownership
      const message = `Record claim: ${claim.tx_hash}`
      const signature = await signMessage({ message })

      return api.recordClaim(account.address, claim, signature)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['claim-history'] })
      queryClient.invalidateQueries({ queryKey: ['leaderboard'] })
      queryClient.invalidateQueries({ queryKey: ['user-rank'] })
    },
  })

  return {
    claims: historyQuery.data || [],
    isLoading: historyQuery.isLoading,
    recordClaim: recordClaimMutation.mutate,
    isRecording: recordClaimMutation.isPending,
  }
}
```

### 6. Update Claim Flow to Record
Modify the claim hooks to record claims after successful transaction:

**frontend/app/dashboard/hooks/use-claim-rewards.ts** (update):

```typescript
import { useClaimHistory } from '@/app/rewards/hooks/use-claim-history'

export function useClaimRewards() {
  const { signAndSubmitTransaction, account } = useAptosWallet()
  const queryClient = useQueryClient()
  const { recordClaim } = useClaimHistory()

  const claimMutation = useMutation({
    mutationFn: async ({ protocolId, rewardIds }: ClaimParams) => {
      const service = getProtocolService(protocolId)
      const rewards = await service.getPendingRewards(account!.address)
      const payload = await service.buildClaimTransaction(account!.address, rewardIds)

      const response = await signAndSubmitTransaction({ data: payload })
      const result = await aptos.waitForTransaction({ transactionHash: response.hash })

      // Record claim to backend
      for (const reward of rewards.filter(r => !rewardIds || rewardIds.includes(r.id))) {
        await recordClaim({
          protocol: protocolId,
          token_symbol: reward.tokenSymbol,
          amount: reward.amount,
          value_usd: reward.valueUsd,
          tx_hash: response.hash,
        })
      }

      return result
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['positions'] })
      queryClient.invalidateQueries({ queryKey: ['rewards'] })
      toast.success('Rewards claimed successfully!')
    },
  })

  return claimMutation
}
```

### 7. Create User Settings Hook
**frontend/lib/hooks/use-user-settings.ts**:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { api } from '@/lib/api'
import { useAptosWallet } from '@/lib/move'

export function useUserSettings() {
  const { account, signMessage } = useAptosWallet()
  const queryClient = useQueryClient()

  const settingsQuery = useQuery({
    queryKey: ['user-settings', account?.address],
    queryFn: () => api.getUserSettings(account!.address),
    enabled: !!account?.address,
  })

  const updateMutation = useMutation({
    mutationFn: async (updates: Partial<UserSettings>) => {
      if (!account) throw new Error('No wallet connected')

      const message = `Update settings: ${Date.now()}`
      const signature = await signMessage({ message })

      return api.updateUserSettings(account.address, updates, signature)
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['user-settings'] })
    },
  })

  return {
    settings: settingsQuery.data,
    isLoading: settingsQuery.isLoading,
    updateSettings: updateMutation.mutate,
    isUpdating: updateMutation.isPending,
  }
}
```

### 8. Create Price Hook
**frontend/lib/hooks/use-prices.ts**:

```typescript
import { useQuery } from '@tanstack/react-query'
import { api } from '@/lib/api'

export function usePrices() {
  return useQuery({
    queryKey: ['token-prices'],
    queryFn: () => api.getTokenPrices(),
    staleTime: 60 * 1000, // 1 minute
    refetchInterval: 60 * 1000, // Auto-refresh every minute
  })
}

export function useTokenPrice(symbol: string) {
  const { data: prices } = usePrices()
  return prices?.[symbol] || 0
}
```

### 9. Update Environment Variables
**frontend/.env.example** (add):

```
NEXT_PUBLIC_API_URL=http://localhost:4000/api
```

### 10. Remove Mock Data Dependencies
Go through services and remove mock data fallbacks for production:

```typescript
// Before
return process.env.NODE_ENV === 'development' ? MOCK_DATA : []

// After
if (process.env.NODE_ENV === 'development' && !process.env.NEXT_PUBLIC_API_URL) {
  console.warn('[Service] Using mock data - API not configured')
  return MOCK_DATA
}
return realData
```

## Deliverables
- [ ] Created `frontend/lib/api/client.ts`
- [ ] Created `frontend/lib/api/index.ts`
- [ ] Created `frontend/lib/api/types.ts`
- [ ] Updated `use-leaderboard.ts` to use API
- [ ] Updated `use-claim-history.ts` to use API
- [ ] Created `use-user-settings.ts` hook
- [ ] Created `use-prices.ts` hook
- [ ] Updated claim flow to record claims
- [ ] Added API URL to environment

## Verification
```bash
# Start backend
cd backend && npm run dev

# Start frontend (different terminal)
cd frontend && yarn dev

# Test flow:
1. Connect wallet
2. Go to leaderboard - should show real data (or empty)
3. Claim a reward
4. Check claim history - should show recorded claim
5. Check leaderboard - rank should update
```

## Testing
- [ ] Leaderboard loads from API
- [ ] User rank displays correctly
- [ ] Claims are recorded after transaction
- [ ] Claim history shows recorded claims
- [ ] Prices update from API
- [ ] Error states handled gracefully

## Notes
- Handle API errors gracefully with toast messages
- Show loading states while fetching
- Keep API calls cached with React Query
- Signature verification prevents fake claim recording
