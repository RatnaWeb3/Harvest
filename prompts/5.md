# Prompt 5: Implement Real Claim Transactions

## Objective
Implement end-to-end claiming functionality that builds real transaction payloads and submits them to Movement network.

## Pre-Flight Checklist
- [ ] Read `docs/issues/move/README.md` for Move transaction issues
- [ ] Read `docs/issues/movement/README.md` for wallet issues
- [ ] Ensure Prompt 2 completed (contracts deployed)
- [ ] Ensure Prompt 4 completed (real data fetching)
- [ ] Load skill: `move-dev`

## Context
The transaction builders exist but need to:
1. Use real deployed contract addresses
2. Handle actual transaction submission
3. Wait for confirmation
4. Update UI state after claim

## Tasks

### 1. Update Transaction Builders
**yuzu-service.ts** - Fix transaction payloads:

```typescript
async buildClaimTransaction(
  address: string,
  rewardIds?: string[]
): Promise<TransactionPayload> {
  const rewards = await this.getPendingRewards(address)
  const rewardsToClaim = rewardIds
    ? rewards.filter((r) => rewardIds.includes(r.id))
    : rewards.filter((r) => r.claimable)

  if (rewardsToClaim.length === 0) {
    throw new Error('No rewards to claim')
  }

  // Group by position for efficient claiming
  const positionIds = [...new Set(rewardsToClaim.map(r => r.positionId))]

  // Build multicall if multiple positions
  if (positionIds.length > 1) {
    return this.buildMultiClaimTransaction(positionIds, address)
  }

  // Single position claim
  const positionId = parseInt(positionIds[0].replace('yuzu-lp-', ''))
  return {
    function: YUZU_CONFIG.entryFunctions.collectFee,
    typeArguments: [],
    functionArguments: [
      positionId.toString(),
      MAX_U128.toString(), // Collect all token0
      MAX_U128.toString(), // Collect all token1
      address,
    ],
  }
}
```

### 2. Update Claim Hooks
**app/dashboard/hooks/use-claim-rewards.ts**:

```typescript
export function useClaimRewards() {
  const { signAndSubmitTransaction } = useAptosWallet()
  const queryClient = useQueryClient()

  const claimMutation = useMutation({
    mutationFn: async ({
      protocolId,
      rewardIds
    }: {
      protocolId: ProtocolId
      rewardIds?: string[]
    }) => {
      const service = getProtocolService(protocolId)
      const payload = await service.buildClaimTransaction(address, rewardIds)

      const response = await signAndSubmitTransaction({
        data: payload,
      })

      // Wait for transaction confirmation
      const result = await aptos.waitForTransaction({
        transactionHash: response.hash,
      })

      return result
    },
    onSuccess: () => {
      // Invalidate queries to refetch positions and rewards
      queryClient.invalidateQueries({ queryKey: ['positions'] })
      queryClient.invalidateQueries({ queryKey: ['rewards'] })

      toast.success('Rewards claimed successfully!')
    },
    onError: (error) => {
      console.error('Claim failed:', error)
      toast.error(`Claim failed: ${error.message}`)
    },
  })

  return claimMutation
}
```

### 3. Update Batch Claim Hook
**app/dashboard/hooks/use-batch-claim.ts**:

```typescript
export function useBatchClaim() {
  const { signAndSubmitTransaction, account } = useAptosWallet()
  const queryClient = useQueryClient()

  const batchClaimMutation = useMutation({
    mutationFn: async (protocolIds: ProtocolId[]) => {
      if (!account) throw new Error('Wallet not connected')

      // Option 1: Use Harvest batch_claim contract
      const payload: TransactionPayload = {
        function: `${HARVEST_MODULE_ADDRESS}::batch_claim::batch_claim`,
        typeArguments: [],
        functionArguments: [
          HARVEST_REGISTRY_ADDRESS, // Registry address
          protocolIds.map(id => getProtocolAddress(id)), // Protocol addresses
        ],
      }

      const response = await signAndSubmitTransaction({ data: payload })
      return await aptos.waitForTransaction({ transactionHash: response.hash })
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['positions'] })
      queryClient.invalidateQueries({ queryKey: ['rewards'] })
      toast.success('Batch claim successful!')
    },
    onError: (error) => {
      // Fallback to sequential claims if batch fails
      console.error('Batch claim failed, trying sequential:', error)
      // Implement sequential fallback
    },
  })

  return batchClaimMutation
}
```

### 4. Update Transaction Status Modal
**components/shared/tx-status-modal.tsx**:

```typescript
interface TxStatusModalProps {
  isOpen: boolean
  onClose: () => void
  status: 'idle' | 'pending' | 'success' | 'error'
  txHash?: string
  error?: string
}

export function TxStatusModal({
  isOpen,
  onClose,
  status,
  txHash,
  error
}: TxStatusModalProps) {
  const explorerUrl = txHash
    ? getExplorerUrl(txHash, 'transaction')
    : undefined

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        {status === 'pending' && (
          <div className="flex flex-col items-center gap-4">
            <Loader2 className="h-12 w-12 animate-spin" />
            <p>Confirming transaction...</p>
            {txHash && (
              <a href={explorerUrl} target="_blank" rel="noopener">
                View on Explorer
              </a>
            )}
          </div>
        )}

        {status === 'success' && (
          <div className="flex flex-col items-center gap-4">
            <CheckCircle className="h-12 w-12 text-green-500" />
            <p>Rewards claimed successfully!</p>
            <a href={explorerUrl} target="_blank" rel="noopener">
              View Transaction
            </a>
          </div>
        )}

        {status === 'error' && (
          <div className="flex flex-col items-center gap-4">
            <XCircle className="h-12 w-12 text-red-500" />
            <p>Transaction failed</p>
            <p className="text-sm text-muted-foreground">{error}</p>
          </div>
        )}
      </DialogContent>
    </Dialog>
  )
}
```

### 5. Integrate with UI Components
**components/protocols/rewards/claim-button.tsx**:

```typescript
export function ClaimButton({ protocolId, rewardIds }: ClaimButtonProps) {
  const { mutate: claim, isPending, isSuccess, isError, error } = useClaimRewards()
  const [showModal, setShowModal] = useState(false)

  const handleClaim = () => {
    setShowModal(true)
    claim({ protocolId, rewardIds })
  }

  return (
    <>
      <Button
        onClick={handleClaim}
        disabled={isPending}
      >
        {isPending ? <Loader2 className="animate-spin" /> : 'Claim'}
      </Button>

      <TxStatusModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        status={isPending ? 'pending' : isSuccess ? 'success' : isError ? 'error' : 'idle'}
        error={error?.message}
      />
    </>
  )
}
```

## Deliverables
- [ ] Updated all protocol service `buildClaimTransaction` methods
- [ ] Updated `use-claim-rewards.ts` with real transaction submission
- [ ] Updated `use-batch-claim.ts` with Harvest contract call
- [ ] Updated `tx-status-modal.tsx` with proper states
- [ ] Updated claim buttons with loading/success/error states
- [ ] All transactions work end-to-end

## Verification
1. Connect wallet with real positions
2. Click "Claim" on a single reward
3. Wallet popup appears with correct transaction
4. Approve transaction
5. Wait for confirmation
6. Positions/rewards refresh automatically
7. Transaction visible on explorer

## Testing Scenarios
- [ ] Single protocol claim works
- [ ] Batch claim works (multiple protocols)
- [ ] Transaction rejection handled gracefully
- [ ] Network error handled gracefully
- [ ] Gas estimation displays correctly
- [ ] Explorer links work

## Notes
- Use `aptos.waitForTransaction()` to confirm before updating UI
- Invalidate React Query cache after successful claim
- Log all transactions for debugging
- Handle "user rejected" error specially (not a real error)
