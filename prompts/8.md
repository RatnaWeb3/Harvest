# Prompt 8: Add Canopy Yield Marketplace Integration

## Objective
Integrate Canopy yield marketplace protocol for tracking vault positions and optimized yield strategies.

## Pre-Flight Checklist
- [ ] Read `docs/issues/move/README.md` for any Move issues
- [ ] Read `docs/protocol-research.md` for Canopy addresses
- [ ] Ensure Prompts 1-7 completed
- [ ] Load skill: `move-dev`

## Context
Canopy is a yield marketplace/optimizer. Users deposit assets into vaults that automatically compound and optimize yields across multiple protocols.

## Tasks

### 1. Create Canopy Configuration
**frontend/constants/protocols/canopy.ts**:

```typescript
const CANOPY_MODULE_ADDRESS =
  process.env.NEXT_PUBLIC_CANOPY_ADDRESS || '0x...'

export const CANOPY_CONFIG = {
  moduleAddress: CANOPY_MODULE_ADDRESS,
  displayName: 'Canopy',
  color: '#22C55E', // Green
  icon: 'canopy',

  viewFunctions: {
    getUserVaults: `${CANOPY_MODULE_ADDRESS}::vault::get_user_deposits`,
    getVaultInfo: `${CANOPY_MODULE_ADDRESS}::vault::get_vault_info`,
    getVaultAPY: `${CANOPY_MODULE_ADDRESS}::vault::current_apy`,
    getPendingYield: `${CANOPY_MODULE_ADDRESS}::vault::pending_yield`,
  },

  entryFunctions: {
    deposit: `${CANOPY_MODULE_ADDRESS}::vault::deposit`,
    withdraw: `${CANOPY_MODULE_ADDRESS}::vault::withdraw`,
    compound: `${CANOPY_MODULE_ADDRESS}::vault::compound`,
    claimYield: `${CANOPY_MODULE_ADDRESS}::vault::claim`,
  },

  // Available vaults
  vaults: [
    {
      id: 'move-stable',
      name: 'MOVE Stable Yield',
      asset: 'MOVE',
      strategy: 'Lending + LP',
    },
    {
      id: 'usdc-optimizer',
      name: 'USDC Optimizer',
      asset: 'USDC',
      strategy: 'Multi-protocol lending',
    },
    {
      id: 'eth-yield',
      name: 'ETH Yield Vault',
      asset: 'ETH',
      strategy: 'LP farming',
    },
  ],
} as const

export const isCanopyDeployed = (): boolean => {
  return CANOPY_MODULE_ADDRESS !== '0x...'
}
```

### 2. Create Canopy Service
**frontend/lib/services/canopy-service.ts**:

```typescript
import { aptos, TransactionPayload } from '@/lib/move'
import { ProtocolService, Position, RewardItem, ProtocolId } from './protocol-interface'
import { CANOPY_CONFIG, isCanopyDeployed } from '@/constants/protocols/canopy'

class CanopyService implements ProtocolService {
  readonly protocolId: ProtocolId = 'canopy'
  readonly displayName = 'Canopy'

  async getPositions(address: string): Promise<Position[]> {
    if (!isCanopyDeployed()) return []

    try {
      const result = await aptos.view({
        payload: {
          function: CANOPY_CONFIG.viewFunctions.getUserVaults,
          typeArguments: [],
          functionArguments: [address],
        },
      })

      const deposits = this.parseDeposits(result)

      return Promise.all(
        deposits.map(async (deposit) => {
          const vaultInfo = await this.getVaultInfo(deposit.vaultId)
          const apy = await this.getVaultAPY(deposit.vaultId)

          return {
            id: `canopy-${deposit.vaultId}`,
            protocolId: 'canopy' as ProtocolId,
            type: 'vault' as const,
            tokenSymbol: vaultInfo.asset,
            tokenAddress: vaultInfo.assetAddress,
            amount: deposit.shares,
            valueUsd: await this.calculateValue(deposit, vaultInfo),
            apy,
            metadata: {
              vaultId: deposit.vaultId,
              vaultName: vaultInfo.name,
              strategy: vaultInfo.strategy,
              shares: deposit.shares,
              pricePerShare: vaultInfo.pricePerShare,
            },
          }
        })
      )
    } catch (error) {
      console.error('[Canopy] Error fetching positions:', error)
      return []
    }
  }

  async getPendingRewards(address: string): Promise<RewardItem[]> {
    if (!isCanopyDeployed()) return []

    try {
      // Get all user vault deposits
      const positions = await this.getPositions(address)

      // For each vault, check pending yield
      const rewards = await Promise.all(
        positions.map(async (pos) => {
          const pending = await this.getPendingYield(address, pos.metadata?.vaultId)
          if (pending === 0n) return null

          return {
            id: `canopy-yield-${pos.metadata?.vaultId}`,
            protocolId: 'canopy' as ProtocolId,
            positionId: pos.id,
            tokenSymbol: pos.tokenSymbol,
            tokenAddress: pos.tokenAddress,
            amount: formatUnits(pending, 8),
            valueUsd: await this.calculateValueUsd(pending, pos.tokenSymbol),
            claimable: true,
          }
        })
      )

      return rewards.filter((r): r is RewardItem => r !== null)
    } catch (error) {
      console.error('[Canopy] Error fetching rewards:', error)
      return []
    }
  }

  async buildClaimTransaction(
    address: string,
    vaultIds?: string[]
  ): Promise<TransactionPayload> {
    // If specific vaults, claim from those
    // Otherwise claim from all vaults with pending yield
    const targetVaults = vaultIds || await this.getVaultsWithPendingYield(address)

    return {
      function: CANOPY_CONFIG.entryFunctions.claimYield,
      typeArguments: [],
      functionArguments: [targetVaults],
    }
  }

  // Auto-compound option
  async buildCompoundTransaction(vaultId: string): Promise<TransactionPayload> {
    return {
      function: CANOPY_CONFIG.entryFunctions.compound,
      typeArguments: [],
      functionArguments: [vaultId],
    }
  }

  private async getVaultInfo(vaultId: string) {
    const result = await aptos.view({
      payload: {
        function: CANOPY_CONFIG.viewFunctions.getVaultInfo,
        typeArguments: [],
        functionArguments: [vaultId],
      },
    })
    return this.parseVaultInfo(result)
  }

  private async getVaultAPY(vaultId: string): Promise<number> {
    const result = await aptos.view({
      payload: {
        function: CANOPY_CONFIG.viewFunctions.getVaultAPY,
        typeArguments: [],
        functionArguments: [vaultId],
      },
    })
    return Number(result[0]) / 100 // Assuming basis points
  }

  private async getPendingYield(address: string, vaultId: string): Promise<bigint> {
    const result = await aptos.view({
      payload: {
        function: CANOPY_CONFIG.viewFunctions.getPendingYield,
        typeArguments: [],
        functionArguments: [address, vaultId],
      },
    })
    return BigInt(result[0] as string)
  }
}

export const canopyService = new CanopyService()
```

### 3. Create Vault Position Card
**frontend/components/protocols/canopy/vault-position-card.tsx**:

```typescript
import { Card } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Position } from '@/lib/services/protocol-interface'
import { TokenDisplay } from '@/components/shared/token-display'
import { ProtocolBadge } from '@/components/shared/protocol-badge'

interface VaultPositionCardProps {
  position: Position
  onCompound?: () => void
}

export function VaultPositionCard({ position, onCompound }: VaultPositionCardProps) {
  return (
    <Card className="p-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <ProtocolBadge protocolId="canopy" />
          <div>
            <p className="font-medium">{position.metadata?.vaultName}</p>
            <p className="text-sm text-muted-foreground">
              Strategy: {position.metadata?.strategy}
            </p>
          </div>
        </div>

        <div className="text-right">
          <TokenDisplay
            amount={position.amount}
            symbol={position.tokenSymbol}
            usdValue={position.valueUsd}
          />
          <p className="text-sm text-green-500">{position.apy.toFixed(2)}% APY</p>
        </div>
      </div>

      <div className="mt-3 flex items-center justify-between">
        <div className="text-xs text-muted-foreground">
          <p>Shares: {position.metadata?.shares}</p>
          <p>Price/Share: {position.metadata?.pricePerShare}</p>
        </div>

        {onCompound && (
          <Button variant="outline" size="sm" onClick={onCompound}>
            Compound
          </Button>
        )}
      </div>
    </Card>
  )
}
```

### 4. Add Compound Hook
**frontend/app/rewards/hooks/use-compound.ts**:

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { useAptosWallet } from '@/lib/move'
import { canopyService } from '@/lib/services/canopy-service'
import { toast } from 'sonner'

export function useCompound() {
  const { signAndSubmitTransaction } = useAptosWallet()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (vaultId: string) => {
      const payload = await canopyService.buildCompoundTransaction(vaultId)
      const response = await signAndSubmitTransaction({ data: payload })
      return await aptos.waitForTransaction({ transactionHash: response.hash })
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['positions'] })
      toast.success('Compounded successfully!')
    },
    onError: (error) => {
      toast.error(`Compound failed: ${error.message}`)
    },
  })
}
```

### 5. Register Service
Update `protocol-registry.ts` and `protocols/index.ts`.

### 6. Add Move Adapter
Create `canopy_adapter.move` in contracts.

## Deliverables
- [ ] Created `frontend/constants/protocols/canopy.ts`
- [ ] Created `frontend/lib/services/canopy-service.ts`
- [ ] Created `frontend/components/protocols/canopy/vault-position-card.tsx`
- [ ] Created compound hook
- [ ] Registered service
- [ ] Created Move adapter

## Verification
```bash
cd frontend && yarn build
yarn dev
# Connect wallet with Canopy vault deposits
# Verify positions and compound button work
```

## Testing
- [ ] Vault positions display correctly
- [ ] APY shows correctly
- [ ] Pending yield calculates correctly
- [ ] Compound action works
- [ ] Claim yield works

## Notes
- Canopy vaults may auto-compound, verify if manual claim is needed
- Price per share increases over time (auto-compound)
- Keep service under 250 lines
- Handle case where vault is paused or deprecated
