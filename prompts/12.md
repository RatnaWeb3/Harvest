# Prompt 12: Add Remaining Protocol Integrations (Mosaic, Moveposition, Matrix.fun)

## Objective
Complete the integration of the remaining 3 protocols: Mosaic (DEX aggregator), Moveposition (lending), and Matrix.fun (engagement/quests).

## Pre-Flight Checklist
- [ ] Read `docs/issues/move/README.md` for any Move issues
- [ ] Read `docs/protocol-research.md` for protocol addresses
- [ ] Ensure Prompts 1-8 completed
- [ ] Load skill: `move-dev`

## Context
These are lower priority protocols but complete the full ecosystem coverage promised in the PRD.

## Tasks

### 1. Mosaic DEX Aggregator
Mosaic aggregates trades across DEXes. Users may have:
- Referral rewards
- Trading rebates
- Points/loyalty rewards

**frontend/constants/protocols/mosaic.ts**:

```typescript
const MOSAIC_MODULE_ADDRESS =
  process.env.NEXT_PUBLIC_MOSAIC_ADDRESS || '0x...'

export const MOSAIC_CONFIG = {
  moduleAddress: MOSAIC_MODULE_ADDRESS,
  displayName: 'Mosaic',
  color: '#EC4899', // Pink
  icon: 'mosaic',

  viewFunctions: {
    getPendingRebates: `${MOSAIC_MODULE_ADDRESS}::rewards::pending_rebates`,
    getReferralRewards: `${MOSAIC_MODULE_ADDRESS}::referral::pending_rewards`,
    getUserPoints: `${MOSAIC_MODULE_ADDRESS}::points::balance`,
  },

  entryFunctions: {
    claimRebates: `${MOSAIC_MODULE_ADDRESS}::rewards::claim_rebates`,
    claimReferral: `${MOSAIC_MODULE_ADDRESS}::referral::claim`,
  },
} as const
```

**frontend/lib/services/mosaic-service.ts**:

```typescript
class MosaicService implements ProtocolService {
  readonly protocolId: ProtocolId = 'mosaic'
  readonly displayName = 'Mosaic'

  async getPositions(address: string): Promise<Position[]> {
    // Mosaic doesn't have positions per se, just rewards
    // Return a "rewards account" position if user has pending rewards
    const rewards = await this.getPendingRewards(address)
    if (rewards.length === 0) return []

    const totalValue = rewards.reduce((sum, r) => sum + r.valueUsd, 0)

    return [{
      id: 'mosaic-rewards',
      protocolId: 'mosaic',
      type: 'staking', // Closest type
      tokenSymbol: 'Rewards',
      tokenAddress: MOSAIC_CONFIG.moduleAddress,
      amount: rewards.length.toString(),
      valueUsd: totalValue,
      apy: 0, // N/A for aggregator rewards
      metadata: {
        rewardCount: rewards.length,
        description: 'Trading rebates and referral rewards',
      },
    }]
  }

  async getPendingRewards(address: string): Promise<RewardItem[]> {
    const rewards: RewardItem[] = []

    // Check trading rebates
    const rebates = await this.getPendingRebates(address)
    if (rebates > 0n) {
      rewards.push({
        id: 'mosaic-rebates',
        protocolId: 'mosaic',
        positionId: 'mosaic-rewards',
        tokenSymbol: 'MOVE',
        tokenAddress: NATIVE_MOVE_ADDRESS,
        amount: formatUnits(rebates, 8),
        valueUsd: await this.calculateValueUsd(rebates),
        claimable: true,
      })
    }

    // Check referral rewards
    const referral = await this.getReferralRewards(address)
    if (referral > 0n) {
      rewards.push({
        id: 'mosaic-referral',
        protocolId: 'mosaic',
        positionId: 'mosaic-rewards',
        tokenSymbol: 'MOVE',
        tokenAddress: NATIVE_MOVE_ADDRESS,
        amount: formatUnits(referral, 8),
        valueUsd: await this.calculateValueUsd(referral),
        claimable: true,
      })
    }

    return rewards
  }

  async buildClaimTransaction(address: string): Promise<TransactionPayload> {
    // Claim both rebates and referral in one tx if both available
    return {
      function: MOSAIC_CONFIG.entryFunctions.claimRebates,
      typeArguments: [],
      functionArguments: [],
    }
  }
}

export const mosaicService = new MosaicService()
```

### 2. Moveposition Lending
Similar to Joule/Echelon but different API structure.

**frontend/constants/protocols/moveposition.ts**:

```typescript
const MOVEPOSITION_MODULE_ADDRESS =
  process.env.NEXT_PUBLIC_MOVEPOSITION_ADDRESS || '0x...'

export const MOVEPOSITION_CONFIG = {
  moduleAddress: MOVEPOSITION_MODULE_ADDRESS,
  displayName: 'Moveposition',
  color: '#F97316', // Orange
  icon: 'moveposition',

  viewFunctions: {
    getUserPosition: `${MOVEPOSITION_MODULE_ADDRESS}::market::get_user_position`,
    getPendingYield: `${MOVEPOSITION_MODULE_ADDRESS}::market::pending_yield`,
  },

  entryFunctions: {
    deposit: `${MOVEPOSITION_MODULE_ADDRESS}::market::deposit`,
    withdraw: `${MOVEPOSITION_MODULE_ADDRESS}::market::withdraw`,
    claimYield: `${MOVEPOSITION_MODULE_ADDRESS}::market::claim_yield`,
  },
} as const
```

**frontend/lib/services/moveposition-service.ts**:

```typescript
class MovepositionService implements ProtocolService {
  readonly protocolId: ProtocolId = 'moveposition'
  readonly displayName = 'Moveposition'

  async getPositions(address: string): Promise<Position[]> {
    if (!isMovepositionDeployed()) return []

    try {
      const result = await aptos.view({
        payload: {
          function: MOVEPOSITION_CONFIG.viewFunctions.getUserPosition,
          typeArguments: [],
          functionArguments: [address],
        },
      })

      return this.parsePositions(result)
    } catch (error) {
      console.error('[Moveposition] Error:', error)
      return []
    }
  }

  async getPendingRewards(address: string): Promise<RewardItem[]> {
    if (!isMovepositionDeployed()) return []

    try {
      const result = await aptos.view({
        payload: {
          function: MOVEPOSITION_CONFIG.viewFunctions.getPendingYield,
          typeArguments: [],
          functionArguments: [address],
        },
      })

      const amount = BigInt(result[0] as string)
      if (amount === 0n) return []

      return [{
        id: 'moveposition-yield',
        protocolId: 'moveposition',
        positionId: 'moveposition-main',
        tokenSymbol: 'MOVE',
        tokenAddress: NATIVE_MOVE_ADDRESS,
        amount: formatUnits(amount, 8),
        valueUsd: await this.calculateValueUsd(amount),
        claimable: true,
      }]
    } catch (error) {
      console.error('[Moveposition] Error:', error)
      return []
    }
  }

  async buildClaimTransaction(): Promise<TransactionPayload> {
    return {
      function: MOVEPOSITION_CONFIG.entryFunctions.claimYield,
      typeArguments: [],
      functionArguments: [],
    }
  }
}

export const movepositionService = new MovepositionService()
```

### 3. Matrix.fun Engagement Platform
Matrix.fun is an engagement/quest platform. Users earn points and rewards for completing tasks.

**frontend/constants/protocols/matrix.ts**:

```typescript
const MATRIX_MODULE_ADDRESS =
  process.env.NEXT_PUBLIC_MATRIX_ADDRESS || '0x...'

export const MATRIX_CONFIG = {
  moduleAddress: MATRIX_MODULE_ADDRESS,
  displayName: 'Matrix.fun',
  color: '#14B8A6', // Teal
  icon: 'matrix',

  // Matrix likely has an API rather than on-chain queries
  apiUrl: process.env.NEXT_PUBLIC_MATRIX_API_URL || 'https://api.matrix.fun',

  viewFunctions: {
    getUserPoints: `${MATRIX_MODULE_ADDRESS}::points::balance`,
    getClaimableRewards: `${MATRIX_MODULE_ADDRESS}::rewards::claimable`,
  },

  entryFunctions: {
    claimRewards: `${MATRIX_MODULE_ADDRESS}::rewards::claim`,
  },
} as const
```

**frontend/lib/services/matrix-service.ts**:

```typescript
class MatrixService implements ProtocolService {
  readonly protocolId: ProtocolId = 'matrix'
  readonly displayName = 'Matrix.fun'

  async getPositions(address: string): Promise<Position[]> {
    // Matrix positions are point balances
    const points = await this.getUserPoints(address)
    if (points === 0) return []

    return [{
      id: 'matrix-points',
      protocolId: 'matrix',
      type: 'staking',
      tokenSymbol: 'Points',
      tokenAddress: MATRIX_CONFIG.moduleAddress,
      amount: points.toString(),
      valueUsd: 0, // Points don't have direct USD value
      apy: 0,
      metadata: {
        type: 'engagement',
        description: 'Quest and engagement points',
      },
    }]
  }

  async getPendingRewards(address: string): Promise<RewardItem[]> {
    try {
      // Check on-chain claimable
      const result = await aptos.view({
        payload: {
          function: MATRIX_CONFIG.viewFunctions.getClaimableRewards,
          typeArguments: [],
          functionArguments: [address],
        },
      })

      const amount = BigInt(result[0] as string)
      if (amount === 0n) return []

      return [{
        id: 'matrix-rewards',
        protocolId: 'matrix',
        positionId: 'matrix-points',
        tokenSymbol: 'MOVE',
        tokenAddress: NATIVE_MOVE_ADDRESS,
        amount: formatUnits(amount, 8),
        valueUsd: await this.calculateValueUsd(amount),
        claimable: true,
      }]
    } catch {
      // Try API fallback
      return this.getRewardsFromApi(address)
    }
  }

  private async getRewardsFromApi(address: string): Promise<RewardItem[]> {
    try {
      const response = await fetch(
        `${MATRIX_CONFIG.apiUrl}/users/${address}/rewards`
      )
      const data = await response.json()
      return this.parseApiRewards(data)
    } catch {
      return []
    }
  }

  async buildClaimTransaction(): Promise<TransactionPayload> {
    return {
      function: MATRIX_CONFIG.entryFunctions.claimRewards,
      typeArguments: [],
      functionArguments: [],
    }
  }

  private async getUserPoints(address: string): Promise<number> {
    try {
      const result = await aptos.view({
        payload: {
          function: MATRIX_CONFIG.viewFunctions.getUserPoints,
          typeArguments: [],
          functionArguments: [address],
        },
      })
      return Number(result[0])
    } catch {
      return 0
    }
  }
}

export const matrixService = new MatrixService()
```

### 4. Register All Services
**frontend/lib/services/protocol-registry.ts** (update):

```typescript
import { mosaicService } from './mosaic-service'
import { movepositionService } from './moveposition-service'
import { matrixService } from './matrix-service'

export const protocolRegistry: Record<ProtocolId, ProtocolService> = {
  yuzu: yuzuService,
  joule: jouleService,
  meridian: meridianService,
  thunderhead: thunderheadService,
  echelon: echelonService,
  layerbank: layerbankService,
  canopy: canopyService,
  mosaic: mosaicService,
  moveposition: movepositionService,
  matrix: matrixService,
}
```

### 5. Update Active Protocols
**frontend/constants/protocols/index.ts**:

```typescript
export const ACTIVE_PROTOCOLS: ProtocolId[] = [
  'yuzu',
  'joule',
  'meridian',
  'thunderhead',
  'echelon',
  'layerbank',
  'canopy',
  'mosaic',
  'moveposition',
  'matrix',
]
```

### 6. Create Move Adapters
Create adapter files for each:
- `contracts/sources/harvest/adapters/mosaic_adapter.move`
- `contracts/sources/harvest/adapters/moveposition_adapter.move`
- `contracts/sources/harvest/adapters/matrix_adapter.move`

## Deliverables
- [ ] Created Mosaic config, service
- [ ] Created Moveposition config, service
- [ ] Created Matrix.fun config, service
- [ ] Registered all services
- [ ] Updated active protocols list (now 10 total)
- [ ] Created Move adapters

## Verification
```bash
cd frontend && yarn build
# Verify no TypeScript errors

yarn dev
# Connect wallet
# All 10 protocols should appear in dashboard
```

## Testing
- [ ] Each new protocol loads without errors
- [ ] Positions display when user has them
- [ ] Rewards calculate correctly
- [ ] Claim transactions build correctly

## Notes
- These protocols may have limited functionality initially
- Focus on rewards tracking even if position data is limited
- Keep services under 200 lines each
- Use graceful error handling - don't break dashboard if one protocol fails
