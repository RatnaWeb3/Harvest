# Prompt 2: Complete and Deploy Move Contracts

## Objective
Complete the Harvest Move smart contracts and deploy them to Movement testnet/mainnet.

## Pre-Flight Checklist
- [ ] Read `docs/issues/move/README.md` for any Move-related issues
- [ ] Read `docs/protocol-research.md` from Prompt 1 (if exists)
- [ ] Load skill: `move-dev` before starting

## Context
The contracts exist in `contracts/sources/harvest/` but have placeholder logic:
- `batch_claim.move` - `execute_protocol_claim()` returns `true` (placeholder)
- Protocol adapters are stubbed
- Contracts are not deployed

## Tasks

### 1. Review Existing Contracts
Read and understand:
- `contracts/sources/harvest/batch_claim.move`
- `contracts/sources/harvest/registry.move`
- `contracts/sources/harvest/errors.move`
- `contracts/sources/harvest/adapters/*.move`

### 2. Complete Protocol Adapters
For each protocol adapter, implement real claim logic:

**Yuzu Adapter** (`adapters/yuzu_adapter.move`):
```move
// Should call Yuzu's collect_fee and collect_reward functions
public fun claim(user: &signer, position_id: u64): bool {
    // Real implementation calling Yuzu contracts
}
```

**Joule Adapter** (`adapters/joule_adapter.move`):
```move
// Should call Joule's claim_interest function
public fun claim(user: &signer): bool {
    // Real implementation
}
```

**Meridian Adapter** (`adapters/meridian_adapter.move`):
```move
// Should call Meridian's harvest function
public fun claim(user: &signer): bool {
    // Real implementation
}
```

### 3. Implement Dynamic Dispatch in batch_claim.move
Replace the placeholder `execute_protocol_claim()`:
```move
fun execute_protocol_claim(user: &signer, protocol: address): bool {
    // Route to appropriate adapter based on protocol address
    if (protocol == @yuzu) {
        yuzu_adapter::claim(user)
    } else if (protocol == @joule) {
        joule_adapter::claim(user)
    } else if (protocol == @meridian) {
        meridian_adapter::claim(user)
    } else {
        false
    }
}
```

### 4. Update Move.toml
Add real protocol addresses as named addresses:
```toml
[addresses]
harvest = "_"
yuzu = "0x..." # Real Yuzu address
joule = "0x..." # Real Joule address
meridian = "0x..." # Real Meridian address
```

### 5. Write Tests
Create comprehensive tests in `contracts/tests/`:
- `batch_claim_tests.move` - Test batch claiming
- `registry_tests.move` - Test protocol registry
- `adapter_tests.move` - Test each adapter

### 6. Compile and Test
```bash
cd contracts
aptos move compile
aptos move test
```

### 7. Deploy to Testnet
```bash
# Initialize account if needed
aptos init --network testnet

# Deploy
aptos move publish --named-addresses harvest=default
```

### 8. Update Frontend Constants
After deployment, update `frontend/lib/move/constants.ts`:
```typescript
export const HARVEST_MODULE_ADDRESS = "0x..." // Deployed address
```

## Deliverables
- [ ] Completed `yuzu_adapter.move` with real logic
- [ ] Completed `joule_adapter.move` with real logic
- [ ] Completed `meridian_adapter.move` with real logic
- [ ] Updated `batch_claim.move` with dynamic dispatch
- [ ] All tests passing
- [ ] Contracts deployed to Movement testnet
- [ ] Frontend constants updated with deployed address

## Verification
```bash
# Compile without errors
cd contracts && aptos move compile

# All tests pass
aptos move test

# Verify deployment
aptos move view --function-id <deployed_address>::batch_claim::max_batch_size
```

## Important Notes
- Keep each Move file under 300 lines
- Use `harvest::errors` for all error codes
- Emit events for all state changes
- If protocol contracts are not available, create mock adapters that can be swapped later
