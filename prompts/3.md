# Prompt 3: Set Up GraphQL Indexer Integration

## Objective
Set up GraphQL indexer integration to query real on-chain position data from Movement network.

## Pre-Flight Checklist
- [ ] Read `docs/issues/indexer/README.md` for any indexer-related issues
- [ ] Read `docs/issues/movement/README.md` for Movement network issues
- [ ] Ensure Prompt 1 completed (protocol addresses known)

## Context
Currently all protocol services use mock data because:
1. Position data (NFTs, lending positions) requires indexer queries
2. Direct RPC view functions don't expose user positions
3. No GraphQL client is set up

## Tasks

### 1. Research Movement Indexer Options
Identify available indexer solutions:
- Movement's official indexer (if available)
- Third-party indexers (e.g., Nodit, custom)
- Protocol-specific subgraphs

Document findings in `docs/indexer-setup.md`.

### 2. Set Up GraphQL Client
Create `frontend/lib/graphql/`:

**client.ts**:
```typescript
import { GraphQLClient } from 'graphql-request'

const INDEXER_URL = process.env.NEXT_PUBLIC_INDEXER_URL ||
  'https://indexer.movementnetwork.xyz/v1/graphql'

export const graphqlClient = new GraphQLClient(INDEXER_URL)
```

**queries/positions.ts**:
```typescript
import { gql } from 'graphql-request'

export const GET_USER_POSITIONS = gql`
  query GetUserPositions($address: String!) {
    # Query structure depends on indexer schema
    positions(where: { owner: $address }) {
      id
      protocol
      tokenAddress
      amount
      # ...
    }
  }
`
```

### 3. Create Position Query Services
For each protocol, create indexer query functions:

**lib/services/queries/yuzu-queries.ts**:
```typescript
export async function fetchYuzuPositions(address: string) {
  // Query Yuzu LP position NFTs from indexer
  const result = await graphqlClient.request(GET_YUZU_POSITIONS, { address })
  return parseYuzuPositions(result)
}
```

### 4. Update Protocol Services
Modify each protocol service to use real indexer data:

**yuzu-service.ts**:
```typescript
async getPositions(address: string): Promise<Position[]> {
  try {
    // Use real indexer query
    const positions = await fetchYuzuPositions(address)
    return positions
  } catch (error) {
    // Fallback to mock in development only
    if (process.env.NODE_ENV === 'development') {
      return MOCK_POSITIONS
    }
    throw error
  }
}
```

### 5. Add Environment Variables
Update `.env.example`:
```
NEXT_PUBLIC_INDEXER_URL=https://indexer.movementnetwork.xyz/v1/graphql
```

### 6. Install Dependencies
```bash
cd frontend
yarn add graphql graphql-request
```

### 7. Create Indexer Types
**lib/graphql/types.ts**:
```typescript
export interface IndexerPosition {
  id: string
  owner: string
  protocol: string
  // ... indexer-specific types
}
```

## Deliverables
- [ ] Created `frontend/lib/graphql/client.ts`
- [ ] Created query files for each protocol
- [ ] Updated protocol services to use real queries
- [ ] Added fallback logic for when indexer unavailable
- [ ] Created `docs/indexer-setup.md` with documentation
- [ ] Updated `.env.example`

## Verification
```bash
# Start dev server
cd frontend && yarn dev

# Check console for real data fetching (not mock)
# Connect wallet and verify positions load from indexer
```

## Fallback Strategy
If Movement indexer is not available or limited:
1. Use direct RPC calls for what's possible
2. Use protocol-specific APIs if available
3. Keep mock data as last resort with clear logging
4. Document limitations in `docs/indexer-setup.md`

## Notes
- Keep query files under 200 lines
- Use React Query for caching (already set up)
- Handle rate limiting gracefully
- Log indexer errors to help debug
