# Prompt 13: Implement Real Airdrop Tracking System

## Objective
Replace the static airdrop data with a real system that tracks Movement ecosystem airdrops, checks eligibility, and allows users to set reminders.

## Pre-Flight Checklist
- [ ] Read `docs/issues/ui/README.md` for any UI issues
- [ ] Ensure Prompts 10-11 completed (backend API)
- [ ] Load skill: `ui-dev`

## Context
The current airdrop tracker uses static mock data. We need:
1. Backend storage for airdrop information
2. Eligibility checking (on-chain and off-chain)
3. Real-time status updates
4. User notifications/reminders

## Tasks

### 1. Create Airdrop Database Schema
Add to backend migrations:

**backend/migrations/002_airdrops.sql**:

```sql
-- Airdrop campaigns
CREATE TABLE airdrops (
  id SERIAL PRIMARY KEY,
  protocol VARCHAR(50) NOT NULL,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  status VARCHAR(20) NOT NULL DEFAULT 'upcoming', -- upcoming, live, claimable, ended
  token_symbol VARCHAR(20),
  total_allocation DECIMAL(36, 18),
  snapshot_date TIMESTAMP,
  claim_start TIMESTAMP,
  claim_end TIMESTAMP,
  requirements JSONB DEFAULT '[]',
  eligibility_type VARCHAR(20) NOT NULL DEFAULT 'on-chain', -- on-chain, api, merkle
  eligibility_contract VARCHAR(66), -- For on-chain checks
  eligibility_api_url TEXT, -- For API checks
  merkle_root VARCHAR(66), -- For merkle proof claims
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- User eligibility cache
CREATE TABLE airdrop_eligibility (
  id SERIAL PRIMARY KEY,
  airdrop_id INTEGER REFERENCES airdrops(id),
  user_address VARCHAR(66) NOT NULL,
  eligible BOOLEAN NOT NULL,
  allocation DECIMAL(36, 18),
  proof JSONB, -- Merkle proof if applicable
  checked_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(airdrop_id, user_address)
);

-- User reminders
CREATE TABLE airdrop_reminders (
  id SERIAL PRIMARY KEY,
  airdrop_id INTEGER REFERENCES airdrops(id),
  user_address VARCHAR(66) NOT NULL,
  remind_at TIMESTAMP NOT NULL,
  notified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(airdrop_id, user_address)
);

-- Indexes
CREATE INDEX idx_airdrops_status ON airdrops(status);
CREATE INDEX idx_eligibility_user ON airdrop_eligibility(user_address);
CREATE INDEX idx_reminders_pending ON airdrop_reminders(remind_at) WHERE NOT notified;
```

### 2. Create Airdrop API Routes
**backend/src/routes/airdrops.ts**:

```typescript
import { Router } from 'express'
import { pool } from '../config/database'
import { airdropService } from '../services/airdrop-service'

const router = Router()

// Get all airdrops
router.get('/', async (req, res) => {
  const { status } = req.query

  let query = 'SELECT * FROM airdrops'
  const params: string[] = []

  if (status) {
    query += ' WHERE status = $1'
    params.push(status as string)
  }

  query += ' ORDER BY claim_start DESC NULLS LAST'

  const result = await pool.query(query, params)
  res.json(result.rows)
})

// Get single airdrop
router.get('/:id', async (req, res) => {
  const { id } = req.params
  const result = await pool.query('SELECT * FROM airdrops WHERE id = $1', [id])

  if (result.rows.length === 0) {
    return res.status(404).json({ error: 'Airdrop not found' })
  }

  res.json(result.rows[0])
})

// Check eligibility
router.get('/:id/eligibility/:address', async (req, res) => {
  const { id, address } = req.params

  // Check cache first
  const cached = await pool.query(`
    SELECT * FROM airdrop_eligibility
    WHERE airdrop_id = $1 AND user_address = $2
    AND checked_at > NOW() - INTERVAL '1 hour'
  `, [id, address.toLowerCase()])

  if (cached.rows.length > 0) {
    return res.json(cached.rows[0])
  }

  // Fetch airdrop details
  const airdrop = await pool.query('SELECT * FROM airdrops WHERE id = $1', [id])
  if (airdrop.rows.length === 0) {
    return res.status(404).json({ error: 'Airdrop not found' })
  }

  // Check eligibility based on type
  const eligibility = await airdropService.checkEligibility(
    airdrop.rows[0],
    address
  )

  // Cache result
  await pool.query(`
    INSERT INTO airdrop_eligibility (airdrop_id, user_address, eligible, allocation, proof)
    VALUES ($1, $2, $3, $4, $5)
    ON CONFLICT (airdrop_id, user_address) DO UPDATE SET
      eligible = $3, allocation = $4, proof = $5, checked_at = NOW()
  `, [id, address.toLowerCase(), eligibility.eligible, eligibility.allocation, eligibility.proof])

  res.json(eligibility)
})

// Set reminder
router.post('/:id/reminder', async (req, res) => {
  const { id } = req.params
  const { address, remind_at } = req.body

  await pool.query(`
    INSERT INTO airdrop_reminders (airdrop_id, user_address, remind_at)
    VALUES ($1, $2, $3)
    ON CONFLICT (airdrop_id, user_address) DO UPDATE SET
      remind_at = $3, notified = FALSE
  `, [id, address.toLowerCase(), remind_at])

  res.json({ success: true })
})

// Get user's reminders
router.get('/reminders/:address', async (req, res) => {
  const { address } = req.params

  const result = await pool.query(`
    SELECT r.*, a.name, a.protocol, a.status
    FROM airdrop_reminders r
    JOIN airdrops a ON r.airdrop_id = a.id
    WHERE r.user_address = $1 AND NOT r.notified
    ORDER BY r.remind_at
  `, [address.toLowerCase()])

  res.json(result.rows)
})

export { router as airdropsRouter }
```

### 3. Create Airdrop Eligibility Service
**backend/src/services/airdrop-service.ts**:

```typescript
import { Aptos, AptosConfig, Network } from '@aptos-labs/ts-sdk'
import { pool } from '../config/database'

const aptos = new Aptos(new AptosConfig({ network: Network.MAINNET }))

interface Airdrop {
  id: number
  eligibility_type: 'on-chain' | 'api' | 'merkle'
  eligibility_contract?: string
  eligibility_api_url?: string
  merkle_root?: string
}

interface EligibilityResult {
  eligible: boolean
  allocation?: string
  proof?: string[]
}

class AirdropService {
  async checkEligibility(
    airdrop: Airdrop,
    address: string
  ): Promise<EligibilityResult> {
    switch (airdrop.eligibility_type) {
      case 'on-chain':
        return this.checkOnChain(airdrop, address)
      case 'api':
        return this.checkApi(airdrop, address)
      case 'merkle':
        return this.checkMerkle(airdrop, address)
      default:
        return { eligible: false }
    }
  }

  private async checkOnChain(
    airdrop: Airdrop,
    address: string
  ): Promise<EligibilityResult> {
    if (!airdrop.eligibility_contract) {
      return { eligible: false }
    }

    try {
      const result = await aptos.view({
        payload: {
          function: `${airdrop.eligibility_contract}::airdrop::check_eligibility`,
          typeArguments: [],
          functionArguments: [address],
        },
      })

      return {
        eligible: Boolean(result[0]),
        allocation: result[1]?.toString(),
      }
    } catch (error) {
      console.error('[Airdrop] On-chain check failed:', error)
      return { eligible: false }
    }
  }

  private async checkApi(
    airdrop: Airdrop,
    address: string
  ): Promise<EligibilityResult> {
    if (!airdrop.eligibility_api_url) {
      return { eligible: false }
    }

    try {
      const response = await fetch(
        `${airdrop.eligibility_api_url}?address=${address}`
      )
      const data = await response.json()

      return {
        eligible: data.eligible || false,
        allocation: data.allocation,
      }
    } catch (error) {
      console.error('[Airdrop] API check failed:', error)
      return { eligible: false }
    }
  }

  private async checkMerkle(
    airdrop: Airdrop,
    address: string
  ): Promise<EligibilityResult> {
    // Query merkle tree data (stored separately or via API)
    // Return proof if eligible
    // This is a placeholder - implement based on merkle tree storage
    return { eligible: false }
  }

  // Admin: Update airdrop status based on dates
  async updateStatuses(): Promise<void> {
    const now = new Date()

    // Upcoming -> Live (if snapshot passed)
    await pool.query(`
      UPDATE airdrops
      SET status = 'live', updated_at = NOW()
      WHERE status = 'upcoming' AND snapshot_date <= $1
    `, [now])

    // Live -> Claimable (if claim started)
    await pool.query(`
      UPDATE airdrops
      SET status = 'claimable', updated_at = NOW()
      WHERE status = 'live' AND claim_start <= $1
    `, [now])

    // Claimable -> Ended (if claim ended)
    await pool.query(`
      UPDATE airdrops
      SET status = 'ended', updated_at = NOW()
      WHERE status = 'claimable' AND claim_end <= $1
    `, [now])
  }
}

export const airdropService = new AirdropService()
```

### 4. Update Frontend Airdrop Types
**frontend/app/airdrops/types.ts**:

```typescript
export interface Airdrop {
  id: number
  protocol: string
  name: string
  description: string
  status: 'upcoming' | 'live' | 'claimable' | 'ended'
  token_symbol: string
  total_allocation: string
  snapshot_date: string | null
  claim_start: string | null
  claim_end: string | null
  requirements: string[]
}

export interface EligibilityResult {
  eligible: boolean
  allocation?: string
  proof?: string[]
  checked_at: string
}

export interface AirdropReminder {
  airdrop_id: number
  remind_at: string
  name: string
  protocol: string
}
```

### 5. Update Frontend Airdrops API
**frontend/lib/api/index.ts** (add):

```typescript
// Airdrops
getAirdrops: (status?: string) =>
  apiClient.get<Airdrop[]>(`/airdrops${status ? `?status=${status}` : ''}`),

getAirdrop: (id: number) =>
  apiClient.get<Airdrop>(`/airdrops/${id}`),

checkEligibility: (airdropId: number, address: string) =>
  apiClient.get<EligibilityResult>(`/airdrops/${airdropId}/eligibility/${address}`),

setReminder: (airdropId: number, address: string, remindAt: string) =>
  apiClient.post(`/airdrops/${airdropId}/reminder`, { address, remind_at: remindAt }),

getReminders: (address: string) =>
  apiClient.get<AirdropReminder[]>(`/airdrops/reminders/${address}`),
```

### 6. Update Airdrops Hook
**frontend/app/airdrops/hooks/use-airdrops.ts**:

```typescript
import { useQuery } from '@tanstack/react-query'
import { api } from '@/lib/api'

export function useAirdrops(status?: string) {
  return useQuery({
    queryKey: ['airdrops', status],
    queryFn: () => api.getAirdrops(status),
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}

export function useAirdrop(id: number) {
  return useQuery({
    queryKey: ['airdrop', id],
    queryFn: () => api.getAirdrop(id),
    enabled: id > 0,
  })
}
```

### 7. Update Eligibility Hook
**frontend/app/airdrops/hooks/use-eligibility-check.ts**:

```typescript
import { useQuery, useMutation } from '@tanstack/react-query'
import { api } from '@/lib/api'
import { useAptosWallet } from '@/lib/move'

export function useEligibilityCheck(airdropId: number) {
  const { account } = useAptosWallet()

  return useQuery({
    queryKey: ['eligibility', airdropId, account?.address],
    queryFn: () => api.checkEligibility(airdropId, account!.address),
    enabled: !!account?.address && airdropId > 0,
    staleTime: 60 * 60 * 1000, // 1 hour (eligibility doesn't change often)
  })
}

export function useSetReminder() {
  const { account } = useAptosWallet()

  return useMutation({
    mutationFn: ({ airdropId, remindAt }: { airdropId: number; remindAt: string }) => {
      if (!account) throw new Error('No wallet connected')
      return api.setReminder(airdropId, account.address, remindAt)
    },
  })
}
```

### 8. Update Airdrop Card with Real Data
**frontend/app/airdrops/components/airdrop-card.tsx** (update to use real API data and eligibility checks)

### 9. Seed Initial Airdrop Data
Create a seed script for known Movement airdrops:

**backend/seeds/airdrops.sql**:

```sql
INSERT INTO airdrops (protocol, name, description, status, token_symbol, requirements, eligibility_type)
VALUES
  ('movement', 'MoveDrop Season 1', 'Rewards for early Movement ecosystem participants', 'claimable', 'MOVE', '["Bridge assets to Movement", "Complete 10+ transactions"]', 'merkle'),
  ('yuzu', 'Yuzu Genesis Airdrop', 'Airdrop for early Yuzu LP providers', 'upcoming', 'YUZU', '["Provide liquidity before snapshot", "Minimum $100 TVL"]', 'on-chain'),
  ('joule', 'Joule Early Adopters', 'Rewards for first 1000 lenders', 'live', 'JOULE', '["Supply assets to any Joule market", "Maintain position for 7+ days"]', 'api');
```

## Deliverables
- [ ] Created database schema for airdrops
- [ ] Created airdrop API routes
- [ ] Created eligibility checking service
- [ ] Updated frontend types
- [ ] Updated frontend API client
- [ ] Updated hooks to use real API
- [ ] Seeded initial airdrop data

## Verification
```bash
# Run migration
cd backend && npm run migrate

# Seed data
psql $DATABASE_URL < seeds/airdrops.sql

# Test API
curl http://localhost:4000/api/airdrops
curl http://localhost:4000/api/airdrops/1/eligibility/0x123...
```

## Testing
- [ ] Airdrops load from API
- [ ] Eligibility check works
- [ ] Results are cached
- [ ] Reminders can be set
- [ ] Status filters work

## Notes
- Cache eligibility results to avoid repeated checks
- Update airdrop statuses via cron job
- Handle different eligibility types gracefully
