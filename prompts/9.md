# Prompt 9: Implement Auto-Compound Feature

## Objective
Implement the auto-compound feature that allows users to automatically reinvest claimed rewards into yield-generating positions.

## Pre-Flight Checklist
- [ ] Read `docs/issues/ui/README.md` for any UI issues
- [ ] Read `docs/issues/move/README.md` for any Move issues
- [ ] Ensure Prompts 1-8 completed (all protocols integrated)
- [ ] Load skill: `ui-dev` and `move-dev`

## Context
The PRD specifies auto-compound as a P1 feature. Users should be able to:
1. Claim rewards and automatically deposit them into a chosen strategy
2. Set up recurring auto-compound (backend scheduler)
3. Choose compound targets (which protocol/pool to deposit into)

## Tasks

### 1. Design Compound Flow
The flow should be:
1. User selects rewards to claim
2. User chooses compound target (e.g., "Deposit into Yuzu MOVE/USDC LP")
3. System calculates:
   - Total reward value
   - Swap path if rewards ≠ deposit token
   - Estimated output
4. User confirms
5. Execute: Claim → Swap (if needed) → Deposit

### 2. Create Compound Strategy Types
**frontend/app/rewards/types.ts** (add):

```typescript
export interface CompoundStrategy {
  id: string
  name: string
  protocolId: ProtocolId
  targetPool: string
  depositToken: string
  apy: number
  description: string
}

export interface CompoundRequest {
  rewards: RewardItem[]
  strategy: CompoundStrategy
  slippage: number // percentage, e.g., 0.5 = 0.5%
}

export interface CompoundQuote {
  totalRewardValue: number
  swapRequired: boolean
  swapPath?: string[]
  estimatedDeposit: number
  estimatedGas: number
  priceImpact: number
}
```

### 3. Create Compound Strategies Hook
**frontend/app/rewards/hooks/use-compound-strategies.ts**:

```typescript
import { useQuery } from '@tanstack/react-query'
import { harvestService } from '@/lib/services/harvest-service'

export function useCompoundStrategies() {
  return useQuery({
    queryKey: ['compound-strategies'],
    queryFn: async () => {
      // Get top APY strategies from each protocol
      const strategies: CompoundStrategy[] = [
        {
          id: 'yuzu-move-usdc',
          name: 'Yuzu MOVE/USDC LP',
          protocolId: 'yuzu',
          targetPool: '0x...',
          depositToken: 'MOVE',
          apy: 42.5,
          description: 'Provide liquidity to earn trading fees',
        },
        {
          id: 'joule-usdc',
          name: 'Joule USDC Lending',
          protocolId: 'joule',
          targetPool: '0x...',
          depositToken: 'USDC',
          apy: 12.5,
          description: 'Lend USDC to earn interest',
        },
        {
          id: 'thunderhead-stmove',
          name: 'Thunderhead stMOVE',
          protocolId: 'thunderhead',
          targetPool: '0x...',
          depositToken: 'MOVE',
          apy: 18.5,
          description: 'Stake MOVE for liquid staking rewards',
        },
        {
          id: 'canopy-move-vault',
          name: 'Canopy MOVE Vault',
          protocolId: 'canopy',
          targetPool: '0x...',
          depositToken: 'MOVE',
          apy: 35.2,
          description: 'Automated yield optimization',
        },
      ]

      // Sort by APY descending
      return strategies.sort((a, b) => b.apy - a.apy)
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}
```

### 4. Create Compound Quote Service
**frontend/lib/services/compound-service.ts**:

```typescript
import { aptos } from '@/lib/move'
import { CompoundRequest, CompoundQuote } from '@/app/rewards/types'
import { yuzuService } from './yuzu-service'

class CompoundService {
  async getQuote(request: CompoundRequest): Promise<CompoundQuote> {
    const { rewards, strategy, slippage } = request

    // Calculate total reward value
    const totalRewardValue = rewards.reduce((sum, r) => sum + r.valueUsd, 0)

    // Determine if swap is needed
    const rewardTokens = [...new Set(rewards.map(r => r.tokenSymbol))]
    const swapRequired = !rewardTokens.includes(strategy.depositToken)

    let estimatedDeposit = totalRewardValue
    let priceImpact = 0
    let swapPath: string[] | undefined

    if (swapRequired) {
      // Get swap quote
      const swapQuote = await this.getSwapQuote(
        rewardTokens[0], // Simplify: assume single reward token
        strategy.depositToken,
        rewards.reduce((sum, r) => sum + Number(r.amount), 0)
      )
      estimatedDeposit = swapQuote.outputValue * (1 - slippage / 100)
      priceImpact = swapQuote.priceImpact
      swapPath = swapQuote.path
    }

    // Estimate gas
    const estimatedGas = swapRequired ? 0.05 : 0.02 // MOVE

    return {
      totalRewardValue,
      swapRequired,
      swapPath,
      estimatedDeposit,
      estimatedGas,
      priceImpact,
    }
  }

  async buildCompoundTransaction(request: CompoundRequest) {
    const { rewards, strategy, slippage } = request

    // Build multi-step transaction:
    // 1. Claim all rewards
    // 2. Swap to deposit token (if needed)
    // 3. Deposit into target strategy

    // For now, use Harvest contract's claim_and_compound
    return {
      function: `${HARVEST_MODULE_ADDRESS}::batch_claim::claim_and_compound`,
      typeArguments: [],
      functionArguments: [
        // Protocol addresses to claim from
        rewards.map(r => getProtocolAddress(r.protocolId)),
        // Compound target
        strategy.targetPool,
        // Slippage tolerance
        Math.floor(slippage * 100), // basis points
      ],
    }
  }

  private async getSwapQuote(tokenIn: string, tokenOut: string, amount: number) {
    // Use Yuzu or aggregator for swap quote
    const quote = await yuzuService.quoteSwap(
      '0x...', // Best pool
      true,
      BigInt(amount * 1e8),
      BigInt(0)
    )

    return {
      outputValue: Number(quote.amountOut) / 1e8,
      priceImpact: 0.3, // Calculate from quote
      path: [tokenIn, tokenOut],
    }
  }
}

export const compoundService = new CompoundService()
```

### 5. Update Compound Tab UI
**frontend/app/rewards/components/compound-tab.tsx**:

```typescript
'use client'

import { useState } from 'react'
import { Card } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group'
import { usePendingRewards } from '@/app/dashboard/hooks/use-pending-rewards'
import { useCompoundStrategies } from '../hooks/use-compound-strategies'
import { useCompound } from '../hooks/use-compound'
import { CompoundQuoteCard } from './compound-quote-card'
import { TxStatusModal } from '@/components/shared/tx-status-modal'

export function CompoundTab() {
  const { data: rewards } = usePendingRewards()
  const { data: strategies } = useCompoundStrategies()
  const { mutate: compound, isPending, isSuccess, isError } = useCompound()

  const [selectedStrategy, setSelectedStrategy] = useState<string | null>(null)
  const [showModal, setShowModal] = useState(false)

  const totalRewardsValue = rewards?.reduce((sum, r) => sum + r.valueUsd, 0) || 0

  const handleCompound = () => {
    if (!selectedStrategy || !rewards) return
    setShowModal(true)
    compound({
      rewards,
      strategyId: selectedStrategy,
      slippage: 0.5,
    })
  }

  if (totalRewardsValue === 0) {
    return (
      <Card className="p-6 text-center">
        <p className="text-muted-foreground">No rewards to compound</p>
      </Card>
    )
  }

  return (
    <div className="space-y-6">
      <Card className="p-4">
        <h3 className="font-medium mb-2">Available to Compound</h3>
        <p className="text-2xl font-bold">${totalRewardsValue.toFixed(2)}</p>
      </Card>

      <div className="space-y-4">
        <h3 className="font-medium">Choose Strategy</h3>
        <RadioGroup value={selectedStrategy || ''} onValueChange={setSelectedStrategy}>
          {strategies?.map((strategy) => (
            <Card
              key={strategy.id}
              className={`p-4 cursor-pointer ${
                selectedStrategy === strategy.id ? 'ring-2 ring-primary' : ''
              }`}
            >
              <RadioGroupItem value={strategy.id} id={strategy.id} />
              <label htmlFor={strategy.id} className="ml-3 cursor-pointer">
                <div className="flex justify-between">
                  <span className="font-medium">{strategy.name}</span>
                  <span className="text-green-500">{strategy.apy}% APY</span>
                </div>
                <p className="text-sm text-muted-foreground">{strategy.description}</p>
              </label>
            </Card>
          ))}
        </RadioGroup>
      </div>

      {selectedStrategy && (
        <CompoundQuoteCard
          rewards={rewards!}
          strategyId={selectedStrategy}
        />
      )}

      <Button
        className="w-full"
        disabled={!selectedStrategy || isPending}
        onClick={handleCompound}
      >
        {isPending ? 'Compounding...' : 'Compound Rewards'}
      </Button>

      <TxStatusModal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
        status={isPending ? 'pending' : isSuccess ? 'success' : isError ? 'error' : 'idle'}
      />
    </div>
  )
}
```

### 6. Create Compound Quote Card
**frontend/app/rewards/components/compound-quote-card.tsx**:

```typescript
import { Card } from '@/components/ui/card'
import { useQuery } from '@tanstack/react-query'
import { compoundService } from '@/lib/services/compound-service'
import { RewardItem, CompoundStrategy } from '../types'

interface CompoundQuoteCardProps {
  rewards: RewardItem[]
  strategyId: string
}

export function CompoundQuoteCard({ rewards, strategyId }: CompoundQuoteCardProps) {
  const { data: quote, isLoading } = useQuery({
    queryKey: ['compound-quote', strategyId, rewards],
    queryFn: () => compoundService.getQuote({
      rewards,
      strategy: getStrategy(strategyId),
      slippage: 0.5,
    }),
    enabled: rewards.length > 0 && !!strategyId,
  })

  if (isLoading) {
    return <Card className="p-4">Calculating...</Card>
  }

  if (!quote) return null

  return (
    <Card className="p-4 space-y-2">
      <div className="flex justify-between text-sm">
        <span className="text-muted-foreground">Total Rewards</span>
        <span>${quote.totalRewardValue.toFixed(2)}</span>
      </div>

      {quote.swapRequired && (
        <div className="flex justify-between text-sm">
          <span className="text-muted-foreground">Swap Path</span>
          <span>{quote.swapPath?.join(' → ')}</span>
        </div>
      )}

      <div className="flex justify-between text-sm">
        <span className="text-muted-foreground">Price Impact</span>
        <span className={quote.priceImpact > 1 ? 'text-red-500' : ''}>
          {quote.priceImpact.toFixed(2)}%
        </span>
      </div>

      <div className="flex justify-between text-sm">
        <span className="text-muted-foreground">Est. Gas</span>
        <span>{quote.estimatedGas} MOVE</span>
      </div>

      <div className="flex justify-between font-medium pt-2 border-t">
        <span>Estimated Deposit</span>
        <span>${quote.estimatedDeposit.toFixed(2)}</span>
      </div>
    </Card>
  )
}
```

### 7. Update Move Contract for Compound
Extend `batch_claim.move` or create new `compound.move`:

```move
module harvest::compound {
    use harvest::batch_claim;
    use harvest::router; // For swaps

    public entry fun claim_and_compound(
        user: &signer,
        registry_addr: address,
        protocols: vector<address>,
        compound_target: address,
        slippage_bps: u64,
    ) {
        // 1. Batch claim all rewards
        batch_claim::batch_claim(user, registry_addr, protocols);

        // 2. Get user's balance of reward tokens
        // 3. Swap to deposit token if needed
        // 4. Deposit into compound target
    }
}
```

## Deliverables
- [ ] Created compound types in `types.ts`
- [ ] Created `use-compound-strategies.ts` hook
- [ ] Created `compound-service.ts`
- [ ] Updated `compound-tab.tsx` with full UI
- [ ] Created `compound-quote-card.tsx`
- [ ] Updated Move contracts for compound

## Verification
```bash
cd frontend && yarn build
yarn dev
# Go to Rewards tab
# Select Compound subtab
# Choose strategy and verify quote
# Execute compound transaction
```

## Testing
- [ ] Strategies load and sort by APY
- [ ] Quote calculates correctly
- [ ] Swap path shows when needed
- [ ] Price impact warning for high impact
- [ ] Transaction executes successfully
- [ ] Positions update after compound

## Notes
- Keep slippage configurable (default 0.5%)
- Show warning for price impact > 1%
- Handle case where swap fails mid-transaction
- Consider gas optimization for compound
